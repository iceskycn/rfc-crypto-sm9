
[[pke]]
== Public Key Encryption And Key Encapsulation

This section specifies an identity-based key encapsulation mechanism and a public key encryption and decryption algorithm built upon pairings on elliptic curves and specifies the corresponding processes.

This section corresponds to the content of <<GMT-0044.4-2016>>.

=== Purpose

The key encapsulation mechanism can be used to encapsulate a secret key to a specific entity. The public key encryption and decryption algorithms are identity-based asymmetric cryptographic algorithms, which allow the sender to encrypt the message using the identity of a receiver, and only the receiver can decrypt the encrypted message using its corresponding private key.

This section applies to the key encapsulation and the encryption and decryption of a message.

The key is a crucial parameter in the control of cryptographic transformations in modern cryptography, and the security of cryptographic output greatly depends on the security of the key. The key encapsulation mechanism enables a user to generate and encrypt a secret key to a target user, such as only the target user can decrypt the secret key, which can be used further as a basis for session keys.

This part specifies an identity-based key encapsulation mechanism realized with elliptic curve pairings. The decapsulating user holds an identity and the corresponding private key, which is generated by the EKGC using the master private key and the user's identity. The encapsulating user generates a secret key and uses the decapsulating user's identity to encrypt the secret key to the decapsulating user, and the decapsulating user obtains the secret key by the decapsulation process with the private key.

This part also describes an identity-based public key encryption algorithm built upon pairings on elliptic curves. The public key encryption algorithm is constructed from the combination of the key encapsulation mechanism described above together with a data encapsulation mechanism to provide data confidentiality. There are two types of data encapsulation mechanisms: stream ciphers based on a key derivation function, and block ciphers combined with a key derivation function. For the identity-based encryption algorithm, the decrypting entity holds an identity and the corresponding private key, which is generated by the EKGC using the master private key and the identity of decrypting entity. The encrypting entity encrypts data with the decrypting entity's identity, and the decrypting entity decrypts the data with its private key.


=== Necessary System Parameters

System parameters listed in <<system-parameters>> as mandatory,
in addition to the following, are required:

* the generator stem:[P_1] is of the cyclic subgroup stem:[G_1] of stem:[E(F_(q^(d_1)))]
of order stem:[N] (where stem:[d_1] divides stem:[k]),

* the generator stem:[P_2] is of the cyclic subgroup of stem:[E(F_(q^(d_2 )))] of order stem:[N] (where stem:[d_2] divides stem:[k]),

* the parameters stem:[d_1], stem:[d_2], both of which are factors of stem:[k].

The homomorphism stem:[\Psi] from stem:[G_2] to stem:[G_1] is an optional parameter.

The range of the bilinear pairing stem:[e] is the multiplicative cyclic group
stem:[G_T] of order stem:[N].

Further description and verification of system parameters are provided
in <<system-parameters>>.

=== Auxiliary Functions Required

The following auxiliary functions are used in this section:

* 3 cryptographic hash functions;
* a key derivation function;
* a blockcipher algorithm;
* a message authentication code algorithm; and
* a random number generator.

The security of the key encapsulation mechanism and the public key encryption algorithm is directly impacted by these auxiliary functions.

See <<aux-functions>> for details.

=== Private Key Generation

==== Generation Of The Encryption Master Key

The EKGC generates a random number stem:[ke in \[1,N - 1\]] as the encryption master private key, computes the element stem:[P_(pub - e) = \[ke \]P_1] in stem:[G_1] as the encryption master public key, and then the encryption master key pair is stem:[(ke, P_(pub - e))]. The EKGC keeps stem:[ke] secret and makes stem:[P_(pub - e)] public.

The EKGC selects a one-byte encryption private key generating function identified by the identifier stem:[hid], and makes it public.

==== Generation Of A User's Encryption Private Key

Let stem:[ID_B] denote the identity of user B.

To generate the encryption private key stem:[de_B] of B, the EKGC first computes stem:[t_1 = H_1(ID_B || hid, N)] over the finite field stem:[F_N].

If stem:[t_1 = 0], it regenerates the encryption master private key, computes the encryption master public key and makes it public, and updates the existing encryption private keys of users. Otherwise, it computes stem:[t_2 = ke * t_1^( - 1)], and then computes stem:[d_(eB) = \[t_2\]P_2].


=== Key Encapsulation Algorithm

In order to encapsulate a key of length stem:[klen] to user B, the encapsulating entity user A shall perform the following steps.

A1: Compute stem:[Q_B = \[H_1(ID_B || hid, N)\]P_1 + P_( pub - e) in G_1].

A2: Generate a random integer stem:[r in \[1,N - 1\]].

A3: Compute stem:[C = \[r\]Q_B]of stem:[G_1], and convert the data type of stem:[C] to bit string as specified in <<convert-point-byte>> and <<convert-byte-bit>>.

A4: Compute stem:[g = e(P_( pub - e),P_2)] of stem:[G_T].

A5: Compute stem:[w = g^r] of stem:[G_T], and convert the data type of stem:[w] to bit string as specified in <<convert-field-byte>> and <<convert-byte-bit>>.

A6: Compute stem:[K = KDF(C || w || ID_B, klen )], if stem:[K = 0], go to A2.

A7: Output stem:[(K,C)], where stem:[K] is the encapsulated key, stem:[C] is the encapsulated ciphertext.

==== Process Diagram

The key encapsulation process is shown in Figure 1.

Figure 1: Key encapsulation process

=== Key Decapsulation Algorithm

After user B receives the ciphertext stem:[C], in order to decapsulate stem:[K], B shall perform the following steps.

B1: Verify that stem:[C in G_1] as specified in <<ec-verify-points>>. If not, report an error and exit.

B2: Compute stem:[w' = e(C, de_B)] of stem:[G_T], and convert the data type of stem:[w'] to bit string as specified in <<convert-field-byte>> and <<convert-byte-bit>>.

B3: Convert the data type of stem:[C] to bit string as specified in <<convert-field-byte>> and <<convert-byte-bit>>, and compute stem:[K' = KDF(C || w' || ID_B, klen )]. If stem:[K' = 0], report an error and exit.

B4: Output stem:[K'].

==== Process Diagram

The key decapsulation process is shown in Figure 2.

Figure 2: Key decapsulation process


=== Public Key Encryption Algorithm

Let stem:[M] be the message to be sent, stem:[mlen] the bit length of stem:[M]. stem:[K_1(_len)] is the bit length of the key stem:[K_1] used with the block cipher. stem:[K_2(_len)] the bit length of the key stem:[K_2] for stem:[MAC(K_2,Z)].

In order to encrypt a message stem:[M] to user B, user A shall perform the following steps.

A1: Compute stem:[Q_B = \[H_1(ID_B || hid, N)\]P_1 + P_(pub - e) in G_1].

A2: Generate a random integer stem:[r in \[1,N - 1\]].

A3: Compute stem:[C_1 = \[r\]Q_B]of stem:[G_1], and convert the data type of stem:[C_1] to bit string as specified in <<convert-point-byte>> and <<convert-byte-bit>>.

A4: Compute stem:[g = e(P_( pub - e),P_2)] of stem:[G_T].

A5: Compute stem:[w = g^r] of stem:[G_T], and convert the data type of stem:[w] to bit string as specified in <<convert-field-byte>> and <<convert-byte-bit>>.

A6: Compute according to the type of encryption algorithm:

. Stream cipher based on the key derivation function

.. Compute stem:[klen = mlen + K_2(_len)], stem:[K = KDF(C_1 || w || ID_B, klen )]. Let stem:[K_1] be the leftmost stem:[mlen] bits of stem:[K], and stem:[K_2] be the remaining stem:[K_2(_len)] bits. If stem:[K_1 = 0], go to A2.

.. Compute stem:[C_2 = M o+ K_1].

. Block cipher combined with the key derivation function


.. Compute stem:[klen = K_1(_len) + K_2(_len)], stem:[K = KDF(C_1 || w || ID_B, klen)]. Let stem:[K_1] be the leftmost stem:[K_1(_len)] bits of stem:[K], and stem:[K_2] be the remaining stem:[K_2(_len)] bits. If stem:[K_1 = 0], go to A2.

.. Compute stem:[C_2 = Enc(K_1,M)].

A7: Compute stem:[C_3 = MAC(K_2,C_2)].

A8: Output ciphertext stem:[C = C_1 || |C_3| || C_2].


==== Process Diagram

The encryption process is shown in Figure 3.

Figure 3: Encryption process


=== Public Key Decryption Algorithm

Let stem:[mlen] be the bit length of stem:[C_2] of ciphertext stem:[C = C_1 || |C_3| || C_2]. stem:[K_(_len)] is the bit length of the key stem:[K_1] used with the block cipher. stem:[K_2(_len)] is the bit length of the key stem:[K_2] for stem:[MAC(K_2,Z)].

In order to decrypt stem:[C], user B needs to perform the following steps.

B1: Extract bit string stem:[C_1] from stem:[C]. Convert the data type of stem:[C_1] to a point on elliptic curve as specified in <<convert-bit-byte>> and <<convert-byte-point>>. Verify stem:[C_1 in G_1] as specified in <<ec-verify-points>>; if not, report an error and exit.

B2: Compute stem:[w' = e(C_1,de_B)] of stem:[G_T], and convert the data type of stem:[w'] to bit string as specified in <<convert-field-byte>> and <<convert-byte-bit>>.

B3: Compute according to the type of encryption algorithm:

. Stream cipher based on the key derivation function

.. Compute stem:[klen = mlen + K_2(_len)], stem:[K' = KDF(C_1 || w' || ID_B, klen )]. Let stem:[K_1'] be the leftmost stem:[mlen] bits of stem:[K'], and stem:[K_2'] be the remaining stem:[K_2(_len)] bits. If stem:[K_1' = 0], report an error and exit;

.. Compute stem:[M' = C_2 o+ K_1'].

. Block cipher combined with the key derivation function

.. Compute stem:[klen = K_1(_len) + K_2(_len)], stem:[K' = KDF(C_1 || w' || ID_B, klen)]. Let stem:[K_1'] be the leftmost stem:[K_1(_len)] bits of stem:[K'], and stem:[K_2'] be the remaining stem:[K_2(_len)] bits. If stem:[K_1' = 0], report an error and exit;

.. Compute stem:[M' = Dec(K_1',C_2)].

B4: Compute stem:[u = MAC(K_2',C_2)]. Extract bit string stem:[C_3] from stem:[C]; if stem:[u != C_3], report an error and exit;

B5: Output plaintext stem:[M'].


==== Process Diagram

The decryption process is shown in Figure 4.

Figure 4: Decryption process

