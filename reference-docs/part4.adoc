= SM9 identity-based cryptographic algorithms, Part 4: Key encapsulation mechanism and public key encryption algorithm

== Scope

This part specifies an identity-based key encapsulation mechanism and a public key encryption and decryption algorithm built upon pairings on elliptic curves and specifies the corresponding processes. The key encapsulation mechanism can be used to encapsulate a secret key to a specific entity. The public key encryption and decryption algorithms are identity-based asymmetric cryptographic algorithms, which allow the sender to encrypt the message using the identity of a receiver, and only the receiver can decrypt the encrypted message using its corresponding private key.

This part applies to the key encapsulation and the encryption and decryption of a message.

== Normative references

The following documents are referred to in the text in such a way that some or all of their content constitutes requirements of this document. For dated references, only the edition cited applies. For undated references, the latest edition of the referenced document (including any amendments) applies.

GM/T 0004‒2012, SM3 cryptographic hash algorithm

GM/T 0002‒2012, SM4 block cipher algorithm

GM/T 0044.1‒2016, SM9 identity-based cryptographic algorithms — Part 1: General

GM/T 0044.3‒2016, SM9 identity-based cryptographic algorithms — Part 3: Key exchange protocol

== Terms and definitions

For the purposes of this document, the following terms and definitions apply.


=== secret key

key shared by both the sender and the receiver in a cryptographic system, unknown to any third party


=== message

bit string of finite length


=== plaintext

unencrypted information


=== ciphertext

data which has been transformed to hide its information content


=== encryption

(invertible) transformation of data by a cryptographic algorithm to generate ciphertext, i.e. to hide the information content of the data


=== decryption

the inverse process of the corresponding encryption


=== key derivation function

function that generates one or more shared private keys from shared secrets and other parameters known to both entities


=== message authentication code (MAC)

authentication algorithm which is used to identify the source and check the integrity of the data by generating a section of code from a specific key and the message, where the function used to obtain the message authentication code is called the message authentication code function


=== encryption master key

topmost key in the key hierarchy of an identity–based cryptographic system, composed of the encryption master private key and the encryption master public key. The encryption master public key is publicly available while the encryption master private key is kept secret by the KGC. The KGC generates the user's encryption private key by using the encryption master private key and the user's identity. In an identity–based cryptographic system, the encryption master private key is usually generated by the KGC using random number generator while the encryption master public key is generated with the encryption master private key and the system parameters


.. *3.10*identity

information that can be used to confirm the identity of an entity, composed of non-repudiable information about the entity, such as its distinguished name, email address, identity card number, and telephone number.


.. *3.11*key generation center (KGC)

trusted authority responsible for the selection of system parameters, generation of the encryption master keys, and generation of users' encryption private keys (in this part)

== Symbols

The following symbols apply to this part.

A, B: two users A and Busing the identity-based cryptographic system

stem:[cf] : the cofactor of the order of an elliptic curve relative to stem:[N]

stem:[cid] : curve identifier that indicates the type of elliptic curve, denoted by one byte, where 0x10 represents an ordinary curve (the non-supersingular curve) over stem:[F_p](the prime number stem:[p > 2^(191)]), 0x11 represents a supersingular curve over stem:[F_p] , and 0x12 represents an ordinary curve and its twisted curve over stem:[F_p]

stem:[Dec()] : block cipher decryption algorithm

stem:[de_B] : encryption private key of the user B

stem:[Enc()] : block cipher encryption algorithm

stem:[e] : a bilinear pairing from stem:[G_1 xx G_2] to stem:[G_T]

stem:[eid] : bilinear pairing identifier to distinguish the type of the bilinear pairing stem:[e], denoted by one byte, where 0x01 represents the Tate pairing, 0x02 represents the Weil pairing, 0x03 represents the Ate pairing, and 0x04 stem:[represents]the R-Ate pairing

stem:[G_T] : a multiplicative cyclic group of prime order stem:[N]

stem:[G_1] : an additive cyclic group of prime order stem:[N]

stem:[G_2] : an additive cyclic group of prime order stem:[N]

stem:[g^u] : stem:[g] to the power of stem:[u], where stem:[g] is an element in the multiplicative group stem:[G_T] and stem:[u] is a positive integer, that is stem:[g^u = underset(ug's)(ubrace (g * g * cdots * g))]

stem:[H_v()] : a cryptographic hash function

stem:[H_1()] , stem:[H_2()]:cryptographic functions derived from the cryptographic hash function

stem:[hid] : identifier of the encryption private key generating function, denoted by one byte, selected and made public by the KGC

stem:[ID_B] : the identity of user B that uniquely determines the public key of B

stem:[KDF()] :the key derivation function

stem:[M] : the message to be encrypted

stem:[M'] : the message obtained by decryption

stem:[MAC()] : the message authentication code function

stem:[N] : the order of the cyclic groups stem:[G_1], stem:[G_2] and stem:[G_T], which is a prime number greater than stem:[2^(191)]

stem:[P_( pub - e)] : the encryption master public key

stem:[P_1] : a generator of stem:[G_1]

stem:[P_2] : a generator of stem:[G_2]

stem:[ke] : the encryption master private key

stem:[(: P :)] : the cyclic group generated by the element stem:[P]

stem:[\[u\]P]
 : the stem:[u] multiple of the element stem:[P] in the additive groups stem:[G_1] or stem:[G_2]

stem:[x || y] : the concatenation of stem:[x] and stem:[y], where stem:[x]and stem:[y] are bit strings or byte strings

stem:[\[x,y\]] : the set of integers which are not less than stem:[x] and not greater than stem:[y]

stem:[o+] : the bitwise XOR operator that operates on two bit strings of the same length

stem:[\beta] : the twisted curve parameter

== Algorithm parameters and auxiliary functions
=== Overview

The key is a crucial parameter in the control of cryptographic transformations in modern cryptography, and the security of cryptographic output greatly depends on the security of the key. The key encapsulation mechanism enables a user to generate and encrypt a secret key to a target user, such as only the target user can decrypt the secret key, which can be used further as a basis for session keys.

This part specifies an identity-based key encapsulation mechanism realized with elliptic curve pairings. The decapsulating user holds an identity and the corresponding private key, which is generated by the KGC using the master private key and the user's identity. The encapsulating user generates a secret key and uses the decapsulating user's identity to encrypt the secret key to the decapsulating user, and the decapsulating user obtains the secret key by the decapsulation process with the private key.

This part also describes an identity-based public key encryption algorithm built upon pairings on elliptic curves. The public key encryption algorithm is constructed from the combination of the key encapsulation mechanism described above together with a data encapsulation mechanism to provide data confidentiality. There are two types of data encapsulation mechanisms: stream ciphers based on a key derivation function, and block ciphers combined with a key derivation function. For the identity-based encryption algorithm, the decrypting entity holds an identity and the corresponding private key, which is generated by the KGC using the master private key and the identity of decrypting entity. The encrypting entity encrypts data with the decrypting entity's identity, and the decrypting entity decrypts the data with its private key.


=== System parameters

The system parameters include: the curve identifier stem:[cid] ,the parameters of the elliptic curve base field
stem:[F_q] ,the parameters of the elliptic curve equation
stem:[a]
 and
stem:[b] ,the twisted curve parameter
stem:[\beta]
 (if the least significant 4 bits of stem:[cid]is 2),the prime factor
stem:[N]
 of the order of the curve and the cofactor
stem:[cf]
 relative to
stem:[N] , the embedding degree
stem:[k] of the curve
stem:[E(F_q)]
 relative to
stem:[N] ,a generator
stem:[P_1]
 of the cyclic subgroup
stem:[G_1]

The range of the bilinear pairing stem:[e] is the multiplicative cyclic group stem:[G_T] of order stem:[N].

For detailed descriptions of the system parameters as well as their verification, please refer to Clause 7 of GM/T 0044.1‒2016.


=== Generation of the encryption master key and the user's encryption private key

The KGC generates a random number stem:[ke in \[1,N - 1\]] as the encryption master private key, computes the element stem:[P_( pub - e) = \[ke \]P_1] in stem:[G_1] as the encryption master public key, and then the encryption master key pair is stem:[( ke ,P_( pub - e))]. The KGC keeps stem:[ke] secret and makes stem:[P_( pub - e)] public.

The KGC selects a one-byte encryption private key generating function identified by the identifier stem:[hid], and makes it public.

Let stem:[ID_B] denote the identity of user B. To generate the encryption private key stem:[de_B] of B, the KGC first computes stem:[t_1 = H_1(ID_B || hid, N)] over the finite field stem:[F_N]. If stem:[t_1 = 0], it regenerates the encryption master private key, computes the encryption master public key and makes it public, and updates the existing encryption private keys of users. Otherwise, it computes stem:[t_2 = ke * t_1^( - 1)], and then computes stem:[d_(eB) = \[t_2\]P_2].


=== Auxiliary functions
==== Overview

Five types of auxiliary functions are used in the identity-based key encapsulation mechanism and the public key encryption algorithm specified in this part: cryptographic hash functions, key derivation functions, message authentication code functions, random number generators and block cipher algorithms. The security of the key encapsulation mechanism and the public key encryption algorithm is directly impacted by these auxiliary functions.



==== Cryptographic hash functions
===== Cryptographic hash function stem:[H_v()]

The output of the cryptographic hash function stem:[H_v()]
 is a
stem:[v] -bit hash value. This part adopts the cryptographic hash functions approved by the State Cryptography Administrationsuch as the
SM3



===== Cryptographic hash function stem:[H_1()]

The input of the cryptographic function stem:[H_1(Z,n)] is a bit string stem:[Z] and an integer stem:[n], and its output is an integer stem:[h_1 in \[1,n - 1\]] . stem:[H_1(Z,n)] invokes the cryptographic hash function stem:[H_v()] internally. stem:[H_v()] is specified in 5.4.2.1.

*Cryptographic function* stem:[H_1(Z,n)]:

Input::a bit string stem:[Z] and an integer stem:[n].

Output:: an integer stem:[h_1 in \[1,n - 1\]].

Step 1: Initialize a 32-bit counter stem:[ct = 0x00000001];

Step 2: Compute stem:[hlen = 8 xx |~ (5 xx ( log_2n)) // 32 ~|];

Step 3: For stem:[i = 1]to stem:[|~ hlen // v ~|]:

Step 3.1: Compute stem:[Ha_i = H_v(0x01 || |Z| || ct )];

Step 3.2: stem:[ct]++;

Step 4: If stem:[hlen // v]is an integer, set stem:[(Ha ! )_( |~ hlen // v ~| ) = Ha_( |~ hlen // v ~| )]. Otherwise, set stem:[H(a ! )_( |~ hlen // v ~| )] to be the leftmost stem:[( hlen - (v xx | __hlen // v__ | ))]bits of stem:[Ha_( |~ hlen // v ~| )].

Step 5: Set stem:[Ha = Ha_1 || |Ha_2| || cdots || Ha_( |~ hlen // v ~| - 1) || H(a ! )_( |~ hlen // v ~| )]. Convert the data type of stem:[Ha] to integer as specified in Clauses 6.2.4 and 6.2.3 of GM/T 0044.1‒2016.

Step 6: Compute stem:[h_1 = (Ha mod (n - 1)) + 1].




===== Cryptographic hash function stem:[H_2()]

The input of the cryptographic function stem:[H_2(Z,n)] is a bit string stem:[Z] and an integer stem:[n], and its output is an integer stem:[h_2 in \[1,n - 1\]]. stem:[H_2(Z,n)] invokes the cryptographic hash function stem:[H_v()] internally. stem:[H_v()] is specified in 5.4.2.1.

*Cryptographic function* stem:[H_2(Z,n)]*:*

Input::a bit string stem:[Z], an integer stem:[n].

Output:: an integer stem:[h_2 in \[1,n - 1\]].

Step 1: Initialize a 32-bit counter stem:[ct = 0x00000001];

Step 2: Compute stem:[hlen = 8 xx |~ (5 xx ( log_2n)) // 32 ~|];

Step 3: For stem:[i = 1]to stem:[|~ hlen // v ~|]:

Step 3.1: Compute stem:[Ha_i = H_v(0x02 || |Z| || ct )];

Step 3.2: stem:[ct]++;

Step 4: If stem:[hlen // v] is an integer, set stem:[H(a ! )_( |~ hlen // v ~| ) = Ha_( |~ hlen // v ~| )]. Otherwise, set stem:[H(a ! )_( |~ hlen // v ~| )] to be the leftmost stem:[( hlen - (v xx | __hlen // v__ | ))]bits of stem:[Ha_( |~ hlen // v ~| )].

Step 5: Set stem:[Ha = Ha_1 || |Ha_2| || cdots vv] stem:[Ha_( |~ hlen // v ~| - 1)] stem:[vv H(a ! )_( |~ hlen // v ~| )] . Convert the data type of stem:[Ha] to integer as specified in Clauses 6.2.4 and 6.2.3of GM/T 0044.1‒2016.

Step 6: Compute stem:[h_2 = (Ha mod (n - 1)) + 1].



==== Key derivation functions

The key derivation functions adopted in this part are specified in Clause 5.4.3 of GM/T 0044.3‒2016.



==== Block cipher algorithms

A block cipher algorithm is comprised of an encryption algorithm stem:[Enc(K_1,m)] and a decryption algorithm stem:[Dec(K_1,c)]. stem:[Enc(K_1,m)] uses the secret key stem:[K_1] to encrypt the plaintext stem:[m] and outputs the ciphertext stem:[c]. stem:[Dec(K_1,c)]uses the secret key stem:[K_1] to decrypt the ciphertext stem:[c] and outputs the plaintext stem:[m] or reports an error. The bit length of stem:[K_1] is denoted by stem:[\[\[len \],\[K_(())\]\]].

This part adopts the block cipher algorithms approved by the State Cryptography Administration, e.g., the SM4 block cipher algorithm.



==== Message authentication code functions

The aim of the message authentication code function stem:[MAC(K_2,Z)] is to protect the message stem:[Z] from unauthorized modifications. The message authentication code of message stem:[Z] is generated under the control of stem:[K_2]. The bit length of stem:[K_2] is denoted by stem:[\[\[len \],\[K_(())\]\]]. For the identity-based encryption algorithm in this part, the message authentication code function uses the key generated by the key derivation function to obtain the message authentication code of the ciphertext, allowing the decrypting entity to identify the message source and verify integrity of the message.

The message authentication code functions invoke the cryptographic hash functions.

Let stem:[H_v()] be a cryptographic hash function and its output is a hash value of length stem:[v] bits long.

*Message authentication code function* stem:[MAC(K_2,Z)]:

Input:: a bit string stem:[K_2] (a key of length stem:[\[\[len \],\[K_(())\]\]] bits) and a bit string stem:[Z] (the message to be processed to obtain MAC).

Output:: a bit string stem:[K] of length stem:[v] (the MAC of the message stem:[Z]).

Step 1: stem:[K = H_v(Z || K_2)].



==== Random number generators

This part adopts the random number generators approved by the State Cryptography Administration.

== Key encapsulation mechanism and its process
=== Key encapsulation algorithm and its process
==== Key encapsulation algorithm

In order to encapsulate a key of length stem:[klen] to user B, the encapsulating entity user A shall perform the following steps.

A1: Compute stem:[Q_B = \[H_1(ID_B || hid, N)\]P_1 + P_( pub - e) in G_1].

A2: Generate a random integer stem:[r in \[1,N - 1\]].

A3: Compute stem:[C = \[r\]Q_B]of stem:[G_1], and convert the data type of stem:[C] to bit string as specified in Clauses 6.2.8 and 6.2.5 of GM/T 0044.1‒2016.

A4: Compute stem:[g = e(P_( pub - e),P_2)] of stem:[G_T].

A5: Compute stem:[w = g^r] of stem:[G_T], and convert the data type of stem:[w] to bit string as specified in Clauses 6.2.6 and 6.2.5 of GM/T 0044.1‒2016.

A6: Compute stem:[K = KDF(C || w || ID_B, klen )], if stem:[K = 0], go to A2.

A7: Output stem:[(K,C)], where stem:[K] is the encapsulated key, stem:[C] is the encapsulated ciphertext.



==== Key encapsulation process

The key encapsulation process is shown in Figure 1.

Figure 1: Key encapsulation process


=== Key decapsulation algorithm and its process
==== Decapsulation algorithm

After user B receives the ciphertext stem:[C], in order to decapsulate stem:[K], B shall perform the following steps.

B1: Verify that stem:[C in G_1] as specified in Clause 4.5 of GM/T 0044.1‒2016. If not,report an error and exit.

B2: Compute stem:[w' = e(C,de_B)] of stem:[G_T], and convert the data type of stem:[w'] to bit string as specified in Clauses 6.2.6 and 6.2.5 of GM/T 0044.1‒2016.

B3: Convert the data type of stem:[C] to bit string as specified in Clauses 6.2.6 and 6.2.5 of GM/T 0044.1‒2016, and compute stem:[K' = KDF(C || w' || ID_B, klen )]. If stem:[K' = 0], report an error and exit.

B4: Output stem:[K'].



==== Key decapsulationprocess

The key decapsulationprocess is shown in Figure 2.

Figure 2: Key decapsulation process

== Public key encryption algorithm and its process
=== Encryption algorithm and its process
==== Encryption algorithm

Let stem:[M] be the message to be sent, stem:[mlen] the bit length of stem:[M]. stem:[\[\[len \],\[K_(())\]\]] is the bit length of the key stem:[K_1] used with the block cipher. stem:[\[\[len \],\[K_(())\]\]] the bit length of the key stem:[K_2] for stem:[MAC(K_2,Z)].

In order to encrypt a message stem:[M] to user B, user A shall perform the following steps.

A1: Compute stem:[Q_B = \[H_1(ID_B || hid, N)\]P_1 + P_( pub - e) in G_1].

A2: Generate a random integer stem:[r in \[1,N - 1\]].

A3: Compute stem:[C_1 = \[r\]Q_B]of stem:[G_1], and convert the data type of stem:[C_1] to bit string as specified in Clauses 6.2.8 and 6.2.5 of GM/T 0044.1‒2016.

A4: Compute stem:[g = e(P_( pub - e),P_2)] of stem:[G_T].

A5: Compute stem:[w = g^r] of stem:[G_T], and convert the data type of stem:[w] to bit string as specified in Clauses 6.2.6 and 6.2.5 of GM/T 0044.1‒2016.

A6: Compute according to the type of encryption algorithm:

. a)Stream cipher based on the key derivation function


1)Compute stem:[klen = mlen + K_2(_len)], stem:[K = KDF(C_1 || w || ID_B, klen )]. Let stem:[K_1] be the leftmost stem:[mlen]bits of stem:[K], and stem:[K_2] be the remaining stem:[\[\[len \],\[K_(())\]\]] bits. If stem:[K_1 = 0], go to A2.

2)Compute stem:[C_2 = M o+ K_1].

. b)Block cipher combined with the key derivation function


1)Compute stem:[\[\[len \],\[len \],\[klen = K_(())K_(())\]\]], stem:[K = KDF(C_1 || w || ID_B, klen )]. Let stem:[K_1] be the leftmost stem:[\[\[len \],\[K_(())\]\]]bits of stem:[K], and stem:[K_2] be the remaining stem:[\[\[len \],\[K_(())\]\]] bits. If stem:[K_1 = 0], go to A2.

2)Compute stem:[C_2 = Enc(K_1,M)].

A7: Compute stem:[C_3 = MAC(K_2,C_2)].

A8: Output ciphertext stem:[C = C_1 || |C_3| || C_2].



==== Encryption process

The encryption process is shown in Figure 3.

Figure 3: Encryption process


=== Decryption algorithm and its process
==== Decryption algorithm

Let stem:[mlen] be the bit length of stem:[C_2] of ciphertext stem:[C = C_1 || |C_3| || C_2]. stem:[\[\[len \],\[K_(())\]\]] is the bit length of the key stem:[K_1] used with the block cipher. stem:[\[\[len \],\[K_(())\]\]] is the bit length of the key stem:[K_2] for stem:[MAC(K_2,Z)].

In order to decrypt stem:[C], user B needs to perform the following steps.

B1: Extract bit string stem:[C_1] from stem:[C]. Convert the data type of stem:[C_1] to a point on elliptic curve as specified in Clauses 6.2.4 and 6.2.9 of GM/T 0044.1‒2016. Verify stem:[C_1 in G_1] as specified in Clause 4.5 of GM/T 0044.;1‒2016; if not,report an error and exit.

B2: Compute stem:[w' = e(C_1,de_B)] of stem:[G_T], and convert the data type of stem:[w'] to bit string as specified in Clauses 6.2.6 and 6.2.5 of GM/T 0044.1‒2016.

B3: Compute according to the type of encryption algorithm:

. a)Stream cipher based on the key derivation function


1)Compute stem:[klen = mlen + K_2(_len)], stem:[K' = KDF(C_1 || w' || ID_B, klen )]. Let stem:[K_1'] be the leftmost stem:[mlen]bits of stem:[K'], and stem:[K_2'] be the remaining stem:[\[\[len \],\[K_(())\]\]] bits. If stem:[K_1' = 0], report an error and exit;

2)Compute stem:[M' = C_2 o+ K_1'].

. b)Block cipher combined with the key derivation function


1)Compute stem:[\[\[len \],\[len \],\[klen = K_(())K_(())\]\]], stem:[K' = KDF(C_1 || w' || ID_B, klen )]. Let stem:[K_1'] be the leftmost stem:[\[\[len \],\[K_(())\]\]]bits of stem:[K'], and stem:[K_2'] be the remaining stem:[\[\[len \],\[K_(())\]\]] bits. If stem:[K_1' = 0], report an error and exit;

2)Compute stem:[M' = Dec(K_1',C_2)].

B4: Compute stem:[u = MAC(K_2',C_2)]. Extract bit string stem:[C_3] from stem:[C]; if stem:[u != C_3], report an error and exit;

B5: Output plaintext stem:[M'].



==== Decryption process

The decryption process is shown in Figure 4.

Figure 4: Decryption process

