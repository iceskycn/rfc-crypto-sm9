[appendix]
== Computation of bilinear pairings over elliptic curves

This appendix corresponds to <<GMT-0044.1-2016,Appendix B>>.

=== Overview

Let an elliptic curve over finite field be stem:[E(F_q)]. If stem:[E(F_q) = cf xx r], stem:[r] is prime, stem:[cf]is the cofactor, then the smallest positive integer stem:[k] satisfying stem:[r || q^k - 1] is known as the elliptic curve's embedding degree relative to stem:[r]. If stem:[G] is an stem:[r] order subgroup of stem:[E(F_q)], the embedding degree of stem:[G] is stem:[k] as well.

Let stem:[overset(´)(F)_q]be an algebraic closure of finite field stem:[F_q], and stem:[E\[r\]] the set of all points of order stem:[r] in _E_( stem:[overset(´)(F)_q]).

=== Miller's algorithm

Let the equation of elliptic curves stem:[E(F_(q^k))] over stem:[F_(q^k)] be stem:[y^2 = x^3 + ax + b], and define the straight line passing through the points stem:[U] and stem:[V] on stem:[E(F_(q^k))] as stem:[g_(U,V) : E(F_(q^k)) -> F_(q^k)]. If the equation of the line passing through the points stem:[U] and stem:[V] is stem:[\lambdax + \deltay + t = 0,] then set function stem:[g_(U,V)(Q) = \lambda x_Q + \delta y_Q + t], where stem:[Q = (x_Q,y_Q)]. When stem:[U = V], stem:[g_(U,V)] is defined as the tangent line passing through the point stem:[U]; if either stem:[U] or stem:[V] is the point at infinity, stem:[g_(U,V)] is a straight line perpendicular to the stem:[x]-axis and passing through the other point. Generally, stem:[g_(U, - U)] is abbreviated as stem:[g_U].

Let stem:[U = (x_U,y_U)], stem:[V = (x_V,y_V)], stem:[Q = (x_Q,y_Q)], stem:[\lambda_1 = (3x_V^2 + a) // (2y_V)], stem:[\lambda_2 = (y_U – y_V) // (x_U – x_V)], then there should have the following properties:

. stem:[g_(U,V)(O) = g_(U,O)(Q) = g_(O,V)(Q) = 1];
. stem:[g_(V,V)(Q) = \lambda_1(x_Q - x_V) - y_Q + y_V,Q != O];
. stem:[g_(U,V)(Q) = \lambda_2(x_Q - x_V) - y_Q + y_V,Q != O,U != +- V];
. stem:[g_(V, - V)(Q) = x_Q - x_V,Q != O].

Miller's algorithm is an efficient algorithm to compute bilinear pairings.

*Miller's algorithm*

Input:: a curve stem:[E], two points stem:[P] and stem:[Q] on stem:[E], and an integer stem:[c].

Output:: stem:[f_(P,c)(Q)].


. The binary representation of stem:[c] is stem:[c_j ... c_1c_0], and the most significant bit stem:[c_j] is 1;

. Set stem:[f = 1], and stem:[V = P];

. For stem:[i = j - 1] to stem:[0]:

.. Compute stem:[f = f^2 * g_(V,V)(Q) // g_(2V)(Q)], stem:[V = \[2\]V];

.. If stem:[c_i = 1], let stem:[f = f * g_(V,P)(Q) // g_(V + P)(Q)], stem:[V = V + P].

. Output stem:[f].

Generally, stem:[f_(P,c)(Q)] is known as the Miller function.

=== Computation of the Weil pairing

Let stem:[E] be an elliptic curve over stem:[F_q], and stem:[r] be a positive integer coprime to stem:[q]. Suppose stem:[\mu_r]is the set of stem:[r]th unit roots, and stem:[k] is the embedding degree relative to stem:[r], that is stem:[r || q^k - 1], then stem:[\mu_r sub F_(q^k)].

Let stem:[G_1 = E\[r\]], stem:[G_2 = E\[r\]], stem:[G_T = \mu_r], then the Weil pairing is a bilinear mapping from stem:[G_1 xx G_2] ==
to stem:[G_T], which is denoted as stem:[e_r].

Let stem:[P in G_1], stem:[Q in G_2], if stem:[P = O] or stem:[Q = O], then stem:[e_r(P,Q) = 1]; if stem:[P != O] and stem:[Q != O], for randomly selected points stem:[T in G_1] and stem:[Q in G_2], which are not the point at infinity, such that neither stem:[P + T] nor stem:[T] equal to stem:[U] or stem:[U + Q], then the Weil pairing is

stem:[e_r(P,Q) = (f_((P + T,r)(Q + U)f_(T,r)(U)f_(U,r)(P + T)f_(Q + U,r)(T)))/(f_((T,r)(Q + U)f_(P + T,r)(U)f_(Q + U,r)(P + T)f_(U,r)(T))) .]

stem:[f_(P + T,r)(Q + U)] , stem:[f_(T,r)(Q + U)], stem:[f_(P + T,r)(U)], stem:[f_(T,r)(U)], stem:[f_(Q + U,r)(P + T)], stem:[f_(Q + U,r)(T)], stem:[f_(U,r)(P + T)], stem:[f_(U,r)(T)] can be computed using the Miller algorithm. If the denominator happens to be 0 during computation, replace the point stem:[T] or stem:[U] and recompute.

=== Computation of the Tate pairing

Let stem:[E] be an elliptic curve over stem:[F_q], stem:[r] be a positive integer coprime to stem:[q], and stem:[k] the embedding degree relative to stem:[r]. Let stem:[Q] be the stem:[r] order on stem:[E(F_(q^k))\[r\]], and stem:[(: Q :)] is the cyclic group generated by stem:[Q]. stem:[(F_(q^k)^())^r] is the set of the stem:[r]th power of each element in stem:[F_(q^k)^()], stem:[(F_(q^k)^())^r] is a subgroup of stem:[F_(q^k)^()], the quotient group of stem:[F_(q^k)^()] about stem:[(F_(q^k)^())^r] is written as stem:[F_(q^k)^() // (F_(q^k)^())^r].

Let stem:[G_1 = E(F_q)\[r\]], stem:[G_2 = (: Q :)], stem:[G_T = F_(q^k)^() // (F_(q^k)^())^r], then the Tate pairing is a bilinear mapping from stem:[G_1 xx G_2] ==
to stem:[G_T], written as stem:[t_r].

Let stem:[P in G_1], stem:[Q in G_2], if stem:[P = O] or stem:[Q = O], then stem:[t_r = 1]; if stem:[P != O] and stem:[Q != O], for randomly selected point stem:[U in E(F_(q^k))] which is not the point at infinity, such that stem:[P != Q], stem:[P != Q + U], stem:[U != - Q], then the Tate pairing is

stem:[t_r(P,Q) = (f_((P,r)(Q + U)))/(f_((P,r)(U))) .]

stem:[f_(P,r)(Q + U)]
 and stem:[f_(P,r)(U)] can be computed using the Miller algorithm. During the computation, if the denominator happens to be 0, replace the point stem:[U] and re-compute.

In practice, the reduced Tate pairings as follows is generally used:

stem:[t_r(P,Q) = {\[\[f_(P,r)(Q)^((q^k - 1)/(r)), ^^ Q != O,\],\[1, ^^ Q = O.\]\]]

The computation amount would be cut in half if the reduced Tate pairings is applied instead of the general Tate pairings. If the embedding degree stem:[k] relative to stem:[r] is an even number, then the computation method of reduced Tate pairings could be further optimized. Algorithm 1 describes the common methods applied to reduce Tate pairings, Algorithm 2, 3 and 4 deal with circumstances when stem:[k = 2d].

==== Algorithm 1

Input:: an integer stem:[r] coprime to stem:[q], stem:[P in E(F_q)\[r\]], stem:[Q in E(F_(q^k))\[r\]].

Output:: stem:[t_r(P,Q)].


. The binary representation of stem:[r] is stem:[r_j ... r_1r_0], and the most significant bit stem:[r_j] is 1;

. Set stem:[f = 1], stem:[V = P];

. For stem:[i = j - 1] to 0:

.. Compute stem:[f = f^2 * g_(V,V)(Q) // g_(2V)(Q)], stem:[V = \[2\]V];

.. If stem:[r_i = 1], let stem:[f = f * g_(V,P)(Q) // g_(V + P)(Q)], stem:[V = V + P].


. Compute stem:[f = f^(q^d - 1)];

. Compute stem:[f = f^((q^d + 1)/r)].

. Output stem:[f].

==== Algorithm 2

Input:: an integer stem:[r] coprime to stem:[q], stem:[P in E(F_q)\[r\]], stem:[Q in E(F_(q^k))\[r\]].

Output:: stem:[t_r(P,Q)].


. The binary representation of stem:[r] is stem:[r_j ... r_1r_0], and the most significant bit stem:[r_j] is 1;

. Set stem:[f = 1], stem:[V = P];

. For stem:[i = j - 1] to 0:

.. Compute stem:[f = f^2 * g_(V,V)(Q) // g_(2V)(Q)], stem:[V = \[2\]V];

.. If stem:[r_i = 1], let stem:[f = f * g_(V,P)(Q) // g_(V + P)(Q)], stem:[V = V + P].


. Compute stem:[f = f^(q^d - 1)];

. Compute stem:[f = f^((q^d + 1)/r)];

. Output stem:[f].

==== Algorithm 3

If stem:[F_(q^k)] ( stem:[k = 2d]) is seen as the quadratic extension of stem:[F_(q^d)], then the elements in stem:[F_(q^k)] can be represented as stem:[w = w_0 + iw_1], where stem:[w_0,w_1 in F_(q^d)], then the conjugate of stem:[w] is stem:[overset(´)(w) = w_0 - iw_1], and in this case, the inverse in algorithm 1 can be replaced with conjugate.

Input:: an integer stem:[r]coprime to stem:[q], stem:[P in E(F_q)\[r\]], stem:[Q in E(F_(q^k))\[r\]].

Output:: stem:[t_r(P,Q)].


. The binary representation of stem:[r] is stem:[r_j ... r_1r_0], and the most significant bit stem:[r_j] is 1;

. Set stem:[f = 1], stem:[V = P];

. For stem:[i = j - 1] to 0:

.. Compute stem:[f = f^2 * g_(V,V)(Q) // g_(2V)(Q)], stem:[V = \[2\]V];

.. If stem:[r_i = 1], let stem:[f = f * g_(V,P)(Q) // overset(´)(g)_(V + P)(Q)], stem:[V = V + P].

. Compute stem:[f = f^(q^d - 1)];

. Compute stem:[f = f^((q^d + 1)/r)];

. Output stem:[f].

==== Algorithm 4

When stem:[q] is a prime greater than 3, then the point stem:[Q in E'], where stem:[E'] is the torsion curve of stem:[E]. In this case, the algorithm could be further optimized.

Input:: stem:[P in E(F_q)\[r\]], stem:[Q in E'(F_(q^d))\[r\]], an integer stem:[r].

Output:: stem:[t_r(P,Q)].

. The binary representation of stem:[r] is stem:[r_j ... r_1r_0], and the most significant bit stem:[r_j] is 1;

. Set stem:[f = 1], stem:[V = P];


. For stem:[i = j - 1] to 0:

.. Compute stem:[f = f^2 * g_(V,V)(Q)], stem:[V = \[2\]V];

.. If stem:[r_i = 1], let stem:[f = f * g_(V,P)(Q)], stem:[V = V + P].

. Compute stem:[f = f^(q^d - 1)];

. Compute stem:[f = f^((q^d + 1)/r)];

. Output stem:[f].

=== Computation of the Ate pairing

Let stem:[\pi_q] be the Frobenius endomorphism, stem:[\pi_q : E -> E,(x,y) |-> (x^q,y^q)]; let stem:[\[q\]] be the mapping: stem:[E -> E,Q |-> \[q\]Q]; stem:[\[1\]] unit map; the dual of stem:[\pi_q] is stem:[\pi_q^'], satisfying stem:[\pi_q * \pi_q^' = \[q\]]; stem:[Ker ()] refers to the kernel of the mapping; let the Frobenius trace of elliptic curve stem:[E(F_q)] be stem:[t], and stem:[T = t - 1].

The computation methods for Ate pairings under various structures are given below.

==== Computation of the Ate pairing over stem:[G_2 xx G_1]

Let stem:[G_1 = E\[r\] nn Ker ( \pi_q - \[1\])], stem:[G_2 = E\[r\] nn Ker ( \pi_q - \[q\])], stem:[P in G_1], stem:[Q in G_2]. Define the Ate pairings over stem:[G_2 xx G_1] as:

[stem]
++++
Ate: G_2 xx G_1 -> F_(q^k)^() // (F_(q^k)^())^r
(Q,P) |-> f_(Q,T)(P)^((q^k - 1) // r)
++++

The computation method for Ate pairings on stem:[G_2 xx G_1] is given below.

Input:: stem:[G_1 = E\[r\] nn Ker ( \pi_q - \[1\])], stem:[G_2 = E\[r\] nn Ker ( \pi_q - \[q\])], stem:[P in G_1], stem:[Q in G_2], an integer stem:[T = t - 1].

Output:: stem:[Ate (Q,P)].

. The binary representation of stem:[T] is stem:[t_j ... t_1t_0], and the most significant bit stem:[t_j] is 1;;

. Set stem:[f = 1], stem:[V = Q];

. For stem:[i = j - 1] to 0:

.. Compute stem:[f = f^2 * g_(V,V)(P)], stem:[V = \[2\]V];

.. If stem:[t_i = 1], compute stem:[f = f * g_(V,Q)(Q) // g_(V + Q)(P)], stem:[V = V + Q].

. Compute stem:[f = f^((q^k - 1) // r)];

. Output stem:[f].

==== Computation of the Ate pairing over stem:[G_1 xx G_2]

For supersingular elliptic curves, the definition and technique of Ate pairings mentioned above can be directly applied; whereas for ordinary curves, stem:[G_2] needs to be transformed to torsion curve before Ate pairings could be defined.

===== Ate pairings on supersingular elliptic curves

Let stem:[E] be a supersingular elliptic curve defined over stem:[F_q],

Let stem:[G_1 = E\[r\] nn Ker ( \pi_q^' - \[q\])], stem:[G_2 = E\[r\] nn Ker ( \pi_q^' - \[1\])], stem:[G_T = F_(q^k)^() // (F_(q^k)^())^r], stem:[P in G_1], stem:[Q in G_2]. Define the Ate pairings over stem:[G_1 xx G_2] as:

stem:[Ate : G_1 xx G_2 -> F_(q^k)^() // (F_(q^k)^())^r] stem:[(P,Q) |-> f_(P,T)(Q)^((q^k - 1) // r) .]

The computation method for Ate pairings on stem:[G_1 xx G_2] is given below.

Input:: stem:[G_1 = E\[r\] nn Ker ( \pi_q^' - \[q\])], stem:[G_2 = E\[r\] nn Ker ( \pi_q^' - \[1\])], stem:[P in G_1], stem:[Q in G_2], an integer stem:[T = t - 1].

Output:: stem:[Ate (P,Q)].

. The binary representation of stem:[T] is stem:[t_j ... t_1t_0], and the most significant bit stem:[t_j] is 1;

. Set stem:[f = 1], stem:[V = P];

. For stem:[i = j - 1] to 0:

.. Compute stem:[f = f^2 * g_(V,V)(Q)], stem:[V = \[2\]V];

.. If stem:[t_i = 1], compute stem:[f = f * g_(V,P)(Q) // g_(V + P)(P)], stem:[V = V + P].

. Compute stem:[f = f^((q^k - 1) // r)];

. Output stem:[f].

===== Ate pairings on ordinary curves

For ordinary curves, there exists an integer stem:[e], making stem:[( \pi_q^')^e] the automorphism on stem:[G_1], thus, torsion curve theory could be applied to establish the relationship between stem:[Ate(P,Q)] and stem:[f_(P,T^e)(Q)], where stem:[T = t + 1], and stem:[t] is trace.

Let stem:[E] be an elliptic curve defined over stem:[F_q], stem:[E'] be the stem:[d] == th
 torsion curve of stem:[E], and stem:[k]its embedding degree, stem:[m = gcd (k,d)], stem:[e = k // m], stem:[\zeta square_m] be the stem:[m] == th
 primitive unit root. The value of stem:[d] has three cases when stem:[p >= 5]:

. stem:[d = 6], stem:[\beta = \zeta_m^( - 6)], stem:[E^' : y^2 = x^3 + \betab], stem:[\varphi_6 : E^' -> E : (x,y) |-> ( \beta^( - 1 // 3)x, \beta^( - 1 // 2)y)], stem:[G_1 = E\[r\] nn Ker ( \pi_q - \[1\])], stem:[G_2 = E^'\[r\] nn Ker (\[\beta^( - 1 // 6)\] \pi_q^e - \[1\])].

. stem:[d = 4], stem:[\beta = \zeta_m^( - 4)], stem:[E^' : y^2 = x^3 + \betaax], stem:[\varphi_4 : E^' -> E : (x,y) |-> ( \beta^( - 1 // 2)x, \beta^( - 3 // 4)y)], stem:[G_1 = E\[r\] nn Ker ( \pi_q - \[1\])], stem:[G_2 = E^'\[r\] nn Ker (\[\beta^( - 1 // 4)\] \pi_q^e - \[1\])].

. stem:[d = 2], stem:[\beta = \zeta_m^( - 2)], stem:[E^' : y^2 = x^3 + \beta^2 ax + \beta^3b], stem:[\varphi_2 : E^' -> E : (x,y) |-> ( \beta^( - 1)x, \beta^( - 3 // 2)y)], stem:[G_1 = E\[r\] nn Ker ( \pi_q - \[1\])], stem:[G_2 = E^'\[r\] nn Ker (\[\beta^( - 1 // 2)\] \pi_q^e - \[1\])].

Let stem:[P in G_1], stem:[Q in G_2]. The Ate pairings on stem:[G_1 xx G_2] ==
are defined as:

stem:[Ate : G_1 xx G_2 -> F_(q^k)^() // (F_(q^k)^())^r] stem:[(P,Q) |-> f_(P,T^e)(Q)^((q^k - 1) // r) .]

The computation method is given below.

Input:: stem:[G_1], stem:[G_2], stem:[P in G_1], stem:[Q in G_2], an integer stem:[T = t - 1].

Output:: stem:[Ate (P,Q)].

. Compute stem:[u = T^e];

. The binary representation of stem:[u] is stem:[t_j ... t_1t_0], and the most significant bit stem:[t_j] is 1;

. Set stem:[f = 1], stem:[V = P];

. For stem:[i = j - 1] to 0:

.. Compute stem:[f = f^2 * g_(V,V)(Q)], stem:[V = \[2\]V];

.. If stem:[t_i = 1], compute stem:[f = f * g_(V,P)(Q) // g_(V + P)(Q)], stem:[V = V + P].

. Compute stem:[f = f^((q^k - 1) // r)];

. Output stem:[f].

If the elliptic curve on which the Ate pairings defined on stem:[G_1 xx G_2]
is based is supersingular, then it is easy to see that Ate pairings are more efficient than Tate pairings. However, for ordinary curves, Ate pairings are more computationally efficient than Tate pairings only when stem:[T^e || <= r], therefore, Ate pairings are recommended only when the value of stem:[t] is relatively small.

=== Computation of the R-ate pairing

==== Definition of the R-ate pairing

The "R" in R-ate can be seen as the ratio of two pairings, and it could also be regarded as a certain fixed power of Tate pairings.

Let stem:[A,B,a,b in Z], stem:[A = aB + b]. The Miller function stem:[f_(Q,A)(P)] has the following features:

stem:[f_(Q,A)(P) = f_(Q,aB + b)(P) = f_(Q,aB)(P) * f_(Q,b)(P) * g_(\[aB\]Q,\[b\]Q)(P) // g_(\[A\]Q)(P) = f_(Q,B)^a(P) * f_(\[B\]Q,a)(P) * f_(Q,b)(P) * (g_((\[aB\]Q,\[b\]Q)(P)))/(g_((\[A\]Q)(P)))]

The R-ate pairing is defined as:

stem:[R_(A,B)(Q,P) = (f_(\[B\]Q,a)(P) * f_(Q,b)(P) * (g_((\[aB\]Q,\[b\]Q)(P)))/(g_((\[A\]Q)(P))))^((q^k - 1) // n) = ((f_((Q,A)(P)))/((f_(Q,B)^a(P))))^((q^k - 1) // n) .]

If stem:[f_(Q,A)(P)] and stem:[f_(Q,B)(P)] are non-degenerate Miller functions, then stem:[R_(A,B)(Q,P)] is a non-degenerate pairing.

Let stem:[L_1,L_2,M_1,M_2 in Z], satisfying

stem:[e_n^(L_1)(Q,P) = (f_(Q,A)(P))^(M_1 * (q^k - 1) // n),] stem:[e_n^(L_2)(Q,P) = (f_(Q,B)(P))^(M_2 * (q^k - 1) // n) .]

Let stem:[M = lcm (M_1,M_2)], stem:[m = (M // M_1) * L_1 - a(M // M_2) * L_2].

For the sake of non-degeneracy, stem:[m] is not divisible by stem:[n]. We have:

stem:[e_n^m(Q,P) = e_n^((M)/(M_1)L_1 - a(M)/(M_2)L_2)(Q,P) = ((e_n(Q,P)^(L_1(M)/(M_1))))/((e_n(Q,P)^(aL_2(M)/(M_2)))) = ((f_((Q,A)(P)))/(f_((Q,B)(P))))^(M * (q^k - 1) // n) .]

It is easy to see that stem:[e_n^m(Q,P) = R_(A,B)(Q,P)^M].


Generally, a non-degenerate pairing cannot be provided by any integer pairing stem:[(A,B)], and stem:[(A,B)] has four cases as follows:

. stem:[(A,B) = (q^i,n)]
. stem:[(A,B) = (q,T_1)]
. stem:[(A,B) = (T_i,T_j)]
. stem:[(A,B) = (n,T_i)]

where stem:[T_i -= q^i( mod n)], stem:[i in Z], and stem:[0 < i < k].

Case 1: stem:[(A,B) = (q^i,n)], because stem:[A = aB + b], that is stem:[q^i = an + b], therefore, stem:[b -= q^i( mod n)], and

[stem]
++++
((f_((Q,q^i)(P)))/((f_(Q,n)^a(P))))^((q^k - 1) // n) = R_(A,B)(Q,P)
= (f_(\[n\]Q,a)(P)f_(Q,b)(P)(g_((\[an \]Q,\[b\]Q)(P)))/(g_((\[q^i\]Q)(P))))^((q^k - 1) // n)
++++

Because stem:[b -= q^i( mod n)], stem:[g_(\[an \]Q,\[b\]Q)(P) = g_(\[q^i\]Q)(P)].
Furthermore, stem:[f_(\[n\]Q,a)(P) = 1]. Hence

[stem]
++++
R_(A,B)(Q,P) = f_(Q,q^i)(P)^((q^k - 1) // n)
++++

Case 2: stem:[(A,B) = (q,T_1)], that is stem:[q = aT_1 + b]. Then

[stem]
++++
((f_((Q,q)(P)))/((f_(Q,T_1)^a(P))))^((q^k - 1) // n) = R_(A,B)(Q,P) =
(f_(\[T_1\]Q,a)(P)f_(Q,b)(P)(g_((\[aT_1\]Q,\[b\]Q)(P)))/(g_((\[q\]Q)(P))))^((q^k - 1) // n)
++++

Since stem:[f_(\[T_1\]Q,a)(P) = f_(Q,a)^q(P)], therefore

[stem]
++++
R_(A,B)(Q,P) = (f_(Q,a)^q(P)f_(Q,b)(P)(g_((\[aT_1\]Q,\[b\]Q)(P)))/(g_((\[q\]Q)(P))))^((q^k - 1) // n)
++++


Case 3: stem:[(A,B) = (T_i,T_j)], that is stem:[T_i = aT_j + b], then

stem:[((f_((Q,T_i)(P)))/((f_(Q,T_j)^a(P))))^((q^k - 1) // n) = R_(A,B)(Q,P) = (f_(\[T_j\]Q,a)(P)f_(Q,b)(P)(g_((\[aT_j\]Q,\[b\]Q)(P)))/(g_((\[q^i\]Q)(P))))^((q^k - 1) // n) .]

Similarly, since stem:[f_(\[T_j\]Q,a)(P) = f_(Q,a)^(q_j)(P)], therefore

[stem]
++++
R_(A,B)(Q,P) = (f_(Q,a)^(q_j)(P)f_(Q,b)(P)(g_((\[aT_1\]Q,\[b\]Q)(P)))/(g_((\[q^i\]Q)(P))))^((q^k - 1) // n)
++++

Case 4: stem:[(A,B) = (n,T_i)], that is stem:[n = aT_i + b], therefore

stem:[((f_((Q,n)(P)))/((f_(Q,T_i)^a(P))))^((q^k - 1) // n) = R_(A,B)(Q,P) = (f_(\[T_i\]Q,a)(P)f_(Q,b)(P)(g_((\[aT_i\]Q,\[b\]Q)(P)))/(g_((\[n\]Q)(P))))^((q^k - 1) // n) .]

Similarly, from stem:[f_(\[T_i\]Q,a)(P) = f_(Q,a)^(q_i)(P)], we have

[stem]
++++
R_(A,B)(Q,P) = (f_(Q,a)^(q_i)(P)f_(Q,b)(P)(g_((\[aT_i\]Q,\[b\]Q)(P)))/(g_((\[n\]Q)(P))))^((q^k - 1) // n)
++++

The R-ate pairing of case 1 is also known as stem:[Ate_i] pairing. Pairing computation of cases 2, 3 and 4 require two Miller loops of length stem:[log a] and stem:[log b] respectively. Case 2 and 4 can only alter one parameter stem:[i] to obtain efficient pairings, while case 3 can alter two parameters. Therefore the R-ate pairings of case 3 are usually chosen, then stem:[(A,B) = (T_i,T_j)].

In order to reduce the degree of the Miller loop, various stem:[i] and stem:[j] can be tried to minimize the integers stem:[a] and stem:[b], thus, the degree of the Miller loop could be reduced to stem:[log(r^(1 // \Phi (k)))].

==== Computation of the R-ate pairing on BN curves

Barreto and Naehrig put forward a method to construct ordinary curves over prime field stem:[F_q] suitable for pairings, and curves constructed via this method are called BN curves. The equation of the BN curves is stem:[E : y^2 = x^3 + b], where stem:[b != 0]. The embedding degree stem:[k = 12], the curve order stem:[r] is a prime. The base field feature is stem:[q], the curve order is stem:[r], and the trace stem:[tr] of the Frobenius mapping can be obtained by the parameter stem:[t]:

stem:[q(t) = 36t^4 + 24t^3 + 24t^2 + 6t + 1] stem:[r(t) = 36t^4 + 36t^3 + 18t^2 + 6t + 1] stem:[tr (t) = 6t^2 + 1]

where stem:[t in Z], such that both stem:[q = q(t)] and stem:[r = r(t)] are primes, and in order to achieve a certain security level, stem:[t] must be large enough, which is at least 63 bits long.

There exists 6th order torsion curves for BN curves over stem:[F_(q^2) : E^' : y^2 = x^3 + \beta b], where stem:[\beta in F_(q^2)], which is neither a square root nor cubic root in stem:[F_(q^2)], such that stem:[r || E'(F_(q^2))]. The points in stem:[G_2] can be represented by the points on the torsion curve stem:[E'], stem:[\varphi_6 : E^' -> E : (x,y) |-> ( \beta^( - 1 // 3)x, \beta^( - 1 // 2)y) .] Thus, the computation of pairings is restricted on the point stem:[P] on stem:[E(F_q)] and the point stem:[Q'] on stem:[E'(F_(q^2))].

Frobenius automorphism is stem:[\pi_q], and stem:[\pi_q : E -> E], stem:[\pi_q(x,y) = (x^q,y^q)], stem:[\pi_(q^2) : E -> E], stem:[\pi_(q^2)(x,y) = (x^(q^2),y^(q^2))].

The computation of R-ate pairing is as follows.

Input:: stem:[P in E(F_q)\[r\]], stem:[Q in E'(F_(q^2))\[r\]], stem:[a = 6t + 2].

Output:: stem:[R_a(Q,P)].

. Suppose stem:[a = sum_(j = 0)^(L - 1)a_i2^j], stem:[a_(L - 1) = 1];

. Set stem:[T = Q], stem:[f = 1];

. For stem:[i = L - 2] to 0:

.. Compute stem:[f = f^2 * g_(T,T)(P)], stem:[T = \[2\]T];

.. If stem:[a_i = 1], compute stem:[f = f * g_(T,Q)(P)], stem:[T = T + Q];

. Compute stem:[Q_1 = \pi_q(Q)], stem:[Q_2 = \pi_(q^2)(Q)];

. Compute stem:[f = f * g_(T,Q_1)(P)], stem:[T = T + Q_1];

. Compute stem:[f = f * g_(T, - Q_2)(P)], stem:[T = T - Q_2];

. Compute stem:[f = f^((q^(12) - 1) // r)];

. Output stem:[f].

For more computation methods for Weil pairings, Tate pairings, Ate pairings and R-ate pairings, please refer to (Barreto P, Lynn, Scott M. 2003), (Barreto P, Galbraith S, et al. 2004), (Eisentrager K, Lauter K, Montgomery P. 2003), (Galbraith S, Harrison K, Soldera D. 2002), (Kobayashi T, Aoki K, Imai H. 2006), (Miller V. 2004), (Scott M. 2005), (Scott M. 2006) and (Scott M, Barreto P. 2004).

=== Elliptic curves suitable for pairings

It is relatively easy to construct bilinear pairings for supersingular curves, yet for curves randomly generated, it is difficult to construct computable pairings. Therefore, when considering ordinary curves, ones with a structure suitable for pairings should be selected.

Assume that stem:[E] is an elliptic curve defined over stem:[F_q], if the three conditions listed below are satisfied, then stem:[E] is a curve suitable for pairings:


. stem:[E(F_q)] has a prime factor stem:[r]no less than stem:[sqrt(q)];

. The embedding degree of stem:[E] relative to stem:[r] is less than stem:[log_2(r) // 8];

. The size of the largest prime factor of stem:[r +- 1] equals that of stem:[r].

Below are the steps to construct elliptic curves suitable for pairings:

Step 1: Select stem:[k], compute integer stem:[t], stem:[r] and stem:[q], so that there exists an elliptic curve stem:[E(F_q)] whose trace is stem:[t], and the curve has a subgroup of prime order stem:[r]and its embedding degree is stem:[k].

Step 2: Use complex multiplication method to compute the equation parameter of this curve over stem:[F_q].

For methods to construct elliptic curves suitable for pairings, please refer to (Atkin A, Morain F. 1993), (Barreto P, Lynn B, Scott M. 2002), (Barreto P, Lynn B, Scott M. 2003), (Barreto P, Naehrig M. 2005), (Brezing F, Weng A. 2005), (Duan P, Cui S, Wah Chan C. 2005), (Dupont R, Enge A, Morain F. 2005), (Freeman D. 2006), (Freeman D, Scott M, Tesk E. 2006), (Lay G, Zimmer H. 1994), (Milne J. 2006.), (Miyaji A, Nakabayashi M, Takano S. 2001), (Scott M. 2006) and (Thuen Ø. 2006).


