= SM9 identity-based cryptographic algorithms, Part 3: Key exchange protocol
:stem:

== Scope

This part of <<GMT-0044-2016>> describes an identity-based key exchange protocol built upon pairings on elliptic curves, and specifies the corresponding processes. This protocol enables two communication entities to compute a shared secret key, which is generated from input provided by both entities, as the result of two or (optionally) three message exchanges over the identity of the peer entity and its own private key. The shared secret key can be used as the session key of symmetric cryptographic algorithms. The optional message exchange step in the protocol allows for key confirmation.

This part applies to key management and agreement.

== Normative references

The following documents are referred to in the text in such a way that some or all of their content constitutes requirements of this document. For dated references, only the edition cited applies. For undated references, the latest edition of the referenced document (including any amendments) applies.

GM/T 0004‒2012, SM3 cryptographic hash algorithm

GM/T 0044.1‒2016, SM9 identity-based cryptographic algorithms ­— Part 1: General

== Terms and definitions

For the purposes of this document, the following terms and definitions apply.


=== key exchange

scheme to exchange keys securely between communication entities, enables both entities to exchange keys securely for transmitting information over an insecure communication channel


=== key agreement

process to generate a shared secret key among multiple users, where no user can determinate the value of the key beforehand


=== key confirmation from A to B

assurance for user B that user A is in possession of the correct key


=== key derivation function

function that generates one or more shared secret keys from shared secrets and other parameters known to both entities


=== initiator

entity which initiates the first round of message exchange in the protocol


=== responder

entity that does not initiate the first round of message exchange in the protocol


=== encryption master key

topmost key in the key hierarchy of an identity–based cryptographic system, composed of the encryption master private key and the encryption master public key.The encryption master public key is publicly available while the encryption master private key is kept secret by the KGC. The KGC generates the user's encryption private key by using the encryption master private key and the user's identity. In an identity–based cryptographic system, the encryption master private key is usually generated by the KGC using random number generators, while the encryption master public key is generatedwith the encryption master private key and the system parameters


=== identity

information that can be used to confirm the identity of an entity, composed of non-repudiable information about the entity, such as its distinguished name, email address, identity card number, and telephone number.


=== key generation center (KGC)

trusted authority responsible for the selection of system parameters, generation of the encryption master keys, and generation of users' encryption private keys (in this part)

== Symbols

The following symbols apply to this part.

A, B: two users A and Busing the identity-based cryptographic system

stem:[cf] : cofactor of the order of an elliptic curve relative to stem:[N]

stem:[cid] : curve identifier that indicates the type of elliptic curve, denoted by one byte, where 0x10 stem:[<annotation encoding="StarMath 5.0" style="margin: 0;"/>]represents an ordinary curve (a non-supersingular curve) over stem:[F_p] (the prime number stem:[p > 2^(191)]), 0x11 represents a supersingular curve over stem:[F_p] , and 0x12 represents an ordinary curve and its twisted curve over stem:[F_p]

stem:[de_A] : the encryption private key of the user A

stem:[de_B] : the encryption private key of the user B

stem:[e] : a bilinear pairing from stem:[G_1 xx G_2] to stem:[G_T]

stem:[eid] : bilinear pairing identifier to distinguish the type of the bilinear pairing stem:[e], denoted by one byte, where 0x01 represents the Tate pairing, 0x02 represents the Weil pairing, 0x03 represents the Ate pairing, and 0x04 represents the R-Ate pairing

stem:[G_T] : a multiplicative cyclic group of prime order stem:[N]

stem:[G_1] : an additive cyclic group of prime order stem:[N]

stem:[G_2] : an additive cyclic group of prime order stem:[N]

stem:[g^u] : stem:[g] to the power of stem:[u], where stem:[g] is an element in the multiplicative group stem:[G_T] and stem:[u] is a positive integer, that is stem:[g^u = underset(ug's)(ubrace (g * g * cdots * g))]

stem:[H_v()] : cryptographic hash functions

stem:[H_1()] , stem:[H_2()]:cryptographic functions derived from the cryptographic hash function

stem:[hid] : identifier of the encryption private key generating function, denoted by one byte, selected and made public by the KGC

stem:[ID_A] : the identity of the user A that uniquely determines the public key of A

stem:[ID_B] : the identity of the user B that uniquely determines the public key of B

stem:[KDF()] : the key derivation function

stem:[N] : the order of the cyclic groups stem:[G_1], stem:[G_2] and stem:[G_T], which is a prime number greater than stem:[2^(191)]

stem:[P_( pub - e)] : the encryption master public key

stem:[P_1] : a generator of stem:[G_1]

stem:[P_2] : a generator of stem:[G_2]

stem:[r_A] : the temporary key generated by the user A during the key exchange

stem:[r_B] : the temporary key generated by the user B during the key exchange

stem:[SK_A] , stem:[SK_B]: the shared secret key agreed in the key exchange protocol

stem:[ke] : the encryption master private key

stem:[⟨P⟩] : the cyclic group generated by the element stem:[P]

stem:[\[u\]P] : the stem:[u] multiple of the element stem:[P] in the additive groups stem:[G_1] or stem:[G_2]

stem:[|~ x ~|] : the ceiling function that maps to the smallest integer not less than stem:[x], for example, stem:[|~ 7 ~| = 7], stem:[|~ 8.3 ~| = 9]

stem:[| __x__ |] : the floor function that maps to the largest integer not greater than stem:[x], for example, stem:[| __7__ | = 7], stem:[| __8.3__ | = 8]

stem:[x ∥ y] : the concatenation of stem:[x] and stem:[y], where stem:[x] and stem:[y] are bit strings or byte strings

stem:[\[x,y\]] : the set of integers which are not less than stem:[x] and not greater than stem:[y]

stem:[\beta] : the twisted curve parameter

== Algorithm parameters and auxiliary functions
=== Overview

This part describes an identity-based key exchange protocol implemented upon pairings of elliptic curves. Both the initiator, user A, and the responder, user B, participates in the key exchange protocol with its identity and its corresponding encryption private key, which is generated by the KGC with the encryption master private key and the user's identity. A and B can negotiate a secret key only known to themselves with their identities and encryption private keys through exchanging messages. Both users can perform key confirmation of its counterpart through an optional message exchange. The shared secret key is often used in some symmetric cryptographic algorithm. This key exchange protocol can be used for key management and key agreement.


=== System parameters

The system parameters include: the curve identifier stem:[cid] ,the parameters of the elliptic curve base field
stem:[F_q] ,the parameters of the elliptic curve equation
stem:[a]
 and
stem:[b] ,the twisted curve parameter
stem:[\beta]
 (if the least significant 4 bits of stem:[cid]is 2),the prime factor
stem:[N]
 of the order of the curve and the cofactor
stem:[cf]
 relative to
stem:[N] , the embedding degree
stem:[k] of the curve
stem:[E(F_q)]
 relative to
stem:[N] ,a generator
stem:[P_1]
 of the cyclic subgroup
stem:[G_1]

The range of the bilinear pairing stem:[e] is the multiplicative cyclic group stem:[G_T] of order stem:[N].

For detailed descriptions of the system parameters as well as their verification, please refer to Clause 7 of GM/T 0044.1‒2016.


=== Generation of the encryption master key and the user's encryption private key

The KGC generates a random number stem:[ke in \[1,N - 1\]] as the encryption master private key, computes the element stem:[P_( pub - e) = \[ke \]P_1] in stem:[G_1] as the encryption master public key, and then the encryption master key pair is stem:[( ke ,P_( pub - e))]. The KGC keeps stem:[ke] secret and makes stem:[P_( pub - e)] public.

The KGC chooses a one-byte encryption private key generating function identifier stem:[hid] and makes it public.

Let stem:[ID_A] and stem:[ID_B] denote the identities of the users A and B respectively. To generate the encryption private key stem:[de_A] of A, the KGC first computes stem:[t_1 = H_1(ID_A ∥ hid ,N) + ke] over the finite field stem:[F_N]. If stem:[t_1 = 0], it regenerates the encryption master private key, computes the encryption master public key and makes it public, and updates the existing encryption private keys of users. Otherwise, it computes stem:[t_2 = ke * t_1^( - 1)], and then computes stem:[de_A = \[t_2\]P_2]. To generate the encryption private key stem:[de_B] of B, the KGC first computes stem:[t_3 = H_1(ID_B ∥ hid ,N) + ke] over the finite field stem:[F_N]. If stem:[t_3 = 0], it regenerates the encryption master private key, computes the encryption master public key and makes it public, and updates the existing encryption private keys of users. Otherwise, it computes stem:[t_4 = ke * t_3^( - 1)], and then computes stem:[de_B = \[t_4\]P_2].


=== Auxiliary functions
==== Overview

There are three types of auxiliary functions used in the identity-based key exchange protocol specified in this part: cryptographic hash functions, key derivation functions and random number generators. The security of the key exchange protocol is directly impacted by these auxiliary functions.



==== Cryptographic hash functions
===== Cryptographic hash function stem:[H_v()]

The output of the cryptographic hash function stem:[H_v()]
 isa
stem:[v] -bit hash value. This part adopts the cryptographic hash functions approved by the State Cryptography Administrationsuch as the
SM3




===== Cryptographic hash function stem:[H_1()]

The input of the cryptographic function stem:[H_1(Z,n)] is a bit string stem:[Z] and an integer stem:[n], and its output is an integer stem:[h_1 in \[1,n - 1\]] . stem:[H_1(Z,n)] invokes the cryptographic hash function stem:[H_v()] internally. stem:[H_v()] is specified in 5.4.2.1.

*Cryptographic function* stem:[H_1(Z,n)]*:*

*Input:*a bit string stem:[Z] and an integer stem:[n].

*Output:* an integer stem:[h_1 in \[1,n - 1\]].

Step 1: Initialize a 32-bit counter stem:[ct = 0x00000001];

Step 2: Compute stem:[hlen = 8 xx |~ (5 xx ( log_2n)) // 32 ~|];

Step 3: For stem:[i = 1]to stem:[|~ hlen // v ~|]:

Step 3.1: Compute stem:[Ha_i = H_v(0x01 vv |Z| vv ct )];

Step 3.2: stem:[ct]++;

Step 4: If stem:[hlen // v]is an integer, set stem:[(Ha ! )_( |~ hlen // v ~| ) = Ha_( |~ hlen // v ~| )]. Otherwise, set stem:[H(a ! )_( |~ hlen // v ~| )] to be the leftmost stem:[( hlen - (v xx | __hlen // v__ | ))]bits of stem:[Ha_( |~ hlen // v ~| )].

Step 5: Set stem:[Ha = Ha_1 vv |Ha_2| vv cdots vv Ha_( |~ hlen // v ~| - 1) vv H(a ! )_( |~ hlen // v ~| )]. Convert the data type of stem:[Ha] to integer as specified in Clauses 6.2.4 and 6.2.3 of GM/T 0044.1‒2016.

Step 6: Compute stem:[h_1 = (Ha mod (n - 1)) + 1].




===== Cryptographic hash function stem:[H_2()]

The input of the cryptographic function stem:[H_2(Z,n)] is a bit string stem:[Z] and an integer stem:[n], and its output is an integer stem:[h_2 in \[1,n - 1\]]. stem:[H_2(Z,n)] invokes the cryptographic hash function stem:[H_v()] internally. stem:[H_v()] is specified in 5.4.2.1.

*Cryptographic function* stem:[H_2(Z,n)]*:*

*Input:*a bit string stem:[Z], an integer stem:[n].

*Output:* an integer stem:[h_2 in \[1,n - 1\]].

Step 1: Initialize a 32-bit counter stem:[ct = 0x00000001];

Step 2: Compute stem:[hlen = 8 xx |~ (5 xx ( log_2n)) // 32 ~|];

Step 3: For stem:[i = 1]to stem:[|~ hlen // v ~|]:

Step 3.1: Compute stem:[Ha_i = H_v(0x02 vv |Z| vv ct )];

Step 3.2: stem:[ct]++;

Step 4: If stem:[hlen // v] is an integer, set stem:[H(a ! )_( |~ hlen // v ~| ) = Ha_( |~ hlen // v ~| )]. Otherwise, set stem:[H(a ! )_( |~ hlen // v ~| )] to be the leftmost stem:[( hlen - (v xx | __hlen // v__ | ))]bits of stem:[Ha_( |~ hlen // v ~| )].

Step 5: Set stem:[Ha = Ha_1 vv |Ha_2| vv cdots vv] stem:[Ha_( |~ hlen // v ~| - 1)] stem:[vv H(a ! )_( |~ hlen // v ~| )] . Convert the data type of stem:[Ha] to integer as specified in Clauses 6.2.4 and 6.2.3of GM/T 0044.1‒2016.

Step 6: Compute stem:[h_2 = (Ha mod (n - 1)) + 1].



==== Key derivation functions

The key derivation function is used to derive keys from a shared secret bit string. In the key agreement process, the key derivation function takes the shared secret bit string obtained in the key exchange process as input, and generates session keys or other secret keys for further encryption.

The key derivation functions invokes cryptographic hash functions specified above.

Let stem:[H_v()] be a cryptographic hash function and its output is a hash value of length stem:[v].

*Key derivation function* stem:[KDF(Z, klen )]*:*

*Input:* a bit string stem:[Z] (shared by both entities) and an integer stem:[klen] (denotes the required bit length of secret keys, and stem:[klen < (2^(32) - 1)v]).

*Output:* a bit string stem:[K] of length stem:[klen].

Step 1: Initialize a stem:[32]-bit counter stem:[ct = 0x00000001].

Step 2: For stem:[i = 1] to stem:[|~ klen // v ~|]:

Step 2.1: Compute stem:[Ha_i = H_v(Z ∥ ct )];

Step 2.2: stem:[ct + +];

Step 3: If stem:[klen // v] is an integer, then set stem:[(Ha ! )_( |~ klen // v ~| ) = Ha_( |~ klen // v ~| )]. Otherwise, set stem:[(Ha ! )_( |~ klen // v ~| )] be the leftmost stem:[( klen - (v xx | __klen // v__ | ))] bits of stem:[Ha_( |~ klen // v ~| )];

Step 4: Set stem:[K = Ha_1 ∥ Ha_2 ∥ cdots ∥ Ha_( |~ klen // v ~| - 1) ∥ (Ha ! )_( |~ klen // v ~| )].



==== Random number generators

This part adopts random number generators approved by the State Cryptography Administration.

== Key exchange protocol and its process
=== Key exchange protocol

Assume that the users A and B are negotiating a bit string of length stem:[klen], where A is the initiator and B is the responder.

In order to obtain the same keys, both A and B shall perform the following steps.

*User A*:

A1: Compute the element stem:[Q_B = \[H_1(ID_B ∥ hid ,N)\]P_1 + P_( pub - e)] over stem:[G_1];

A2: Generate a random number stem:[r_A in \[1,N - 1\]];

A3: Compute the element stem:[R_A = \[r_A\]Q_B] over stem:[G_1];

A4: Send stem:[R_A] to B;

*User B*:

B1: Compute the element stem:[Q_A = \[H_1(ID_A ∥ hid ,N)\]P_1 + P_( pub - e)] over stem:[G_1];

B2: Generate a random number stem:[r_B in \[1,N - 1\]];

B3: Compute the element stem:[R_B = \[r_B\]Q_A] over stem:[G_1];

B4: Verify stem:[R_A in G_1] as specified in Clause 4.5 of GM/T 0044.1‒2016. If not, the protocol fails. Otherwise, compute over stem:[G_T]: stem:[g_1 = e(R_A, de_B)], stem:[g_2 = e(P_( pub - e),P_2)^(r_B)], stem:[g_3 = g_1^(r_B)]. Convert the data type of stem:[g_1], stem:[g_2], stem:[g_3] to bit string as specified in Clauses6.2.8 and 6.2.5 of GM/T 0044.1‒2016.

B5: Convert the data type of stem:[R_A] and stem:[R_B] to bit string as specified in Clauses 6.2.6 and 6.2.5 of GM/T 0044.1‒2016, and compute stem:[SK_B = KDF(ID_A ∥ ID_B ∥ R_A ∥ R_B ∥ g_1 ∥ g_2 ∥ g_3, klen )].

B6: (Optional) Compute stem:[S_B = H_v(0x82 ∥ g_1 ∥ H_v(g_2 ∥ g_3 ∥ ID_A ∥ ID_B ∥ R_A ∥ R_B))].

B7: Send stem:[R_B] and (optionally) stem:[S_B] to A.

*User A*:

A5: Verify stem:[R_B in G_1] as specified in Clause 4.5 of GM/T 0044.1‒2016. If not, the protocol fails. Otherwise, compute over stem:[G_T]: stem:[g_1^' = e(P_( pub - e),P_2)^(r_A)], stem:[g_2^' = e(R_B, de_A)], stem:[g_3^' = (g_2^')^(r_A)]. Convert the data type of stem:[g_1^'], stem:[g_2^'], stem:[g_3^'] to bit string as specified in Clauses6.2.6 and 6.2.5 of GM/T 0044.1‒2016.

A6: Convert the data type of stem:[R_A] and stem:[R_B] to bit string as specified in Clauses 6.2.8 and 6.2.5 of GM/T 0044.1‒2016, and (optionally) compute stem:[S_1 = H_v(0x82 ∥ g_1^' ∥ H_v(g_2^' ∥ g_3^' ∥ ID_A ∥ ID_B ∥ R_A ∥ R_B))], and verify if stem:[S_1 = S_B], if not, the key confirmation from B to A fails.

A7: Compute stem:[SK_A = KDF(ID_A ∥ ID_B ∥ R_A ∥ R_B ∥ g_1^' ∥ g_2^' ∥ g_3^', klen )].

A8: (Optional) Compute stem:[S_A = H_v(0x83 ∥ g_1^' ∥ H_v(g_2^' ∥ g_3^' ∥ ID_A ∥ ID_B ∥ R_A ∥ R_B))] and send stem:[S_A] to B.

*User B*:

B8: (Optional) Compute stem:[S_2 = H_v(0x83 ∥ g_1 ∥ H_v(g_2 ∥ g_3 ∥ ID_A ∥ ID_B ∥ R_A ∥ R_B))], and verify if stem:[S_2 = S_A], if not, the key confirmation from A to B fails.


=== Key exchange process

The process of the key exchange protocol is shown in <<_Ref451941925,Figure 1>>.

No

No

No

No

