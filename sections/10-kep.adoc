
[[kep]]
== Key Exchange Protocol

This section specifies an identity-based key exchange protocol built upon pairings on elliptic curves.

This section corresponds to the content of <<GMT-0044.3-2016>>.

=== Purpose

This protocol enables two communication entities to compute a shared secret key, which is generated from input provided by both entities, as the result of two or (optionally) three message exchanges over the identity of the peer entity and its own private key. The shared secret key can be used as the session key of symmetric cryptographic algorithms. The optional message exchange step in the protocol allows for key confirmation.

This section applies to key management and agreement.


This part describes an identity-based key exchange protocol implemented upon pairings of elliptic curves. Both the initiator, user A, and the responder, user B, participates in the key exchange protocol with its identity and its corresponding encryption private key, which is generated by the EKGC with the encryption master private key and the user's identity. A and B can negotiate a secret key only known to themselves with their identities and encryption private keys through exchanging messages. Both users can perform key confirmation of its counterpart through an optional message exchange. The shared secret key is often used in some symmetric cryptographic algorithm. This key exchange protocol can be used for key management and key agreement.


=== Necessary System Parameters

System parameters listed in <<system-parameters>> as mandatory,
in addition to the following, are required:

* the generator stem:[P_1] is of the cyclic subgroup stem:[G_1] of stem:[E(F_(q^(d_1)))]
of order stem:[N] (where stem:[d_1] divides stem:[k]),

* the generator stem:[P_2] is of the cyclic subgroup of stem:[E(F_(q^(d_2 )))] of order stem:[N] (where stem:[d_2] divides stem:[k]),

* the parameters stem:[d_1], stem:[d_2], both of which are factors of stem:[k].

The homomorphism stem:[\Psi] from stem:[G_2] to stem:[G_1] is an optional parameter.

The range of the bilinear pairing stem:[e] is the multiplicative cyclic group
stem:[G_T] of order stem:[N].

Further description and verification of system parameters are provided
in <<system-parameters>>.


=== Auxiliary Functions Required

The following auxiliary functions are used in this section:

* cryptographic hash functions,
* key derivation functions, and
* random number generators.

The security of the resulting key exchange protocol is directly impacted by these auxiliary functions.

See <<aux-functions>> for details.


=== Private Key Generation

==== Generation Of The Encryption Master Key

The EKGC generates a random number stem:[ke in \[1,N - 1\]] as the encryption master private key, computes the element stem:[P_( pub - e) = \[ke \]P_1] in stem:[G_1] as the encryption master public key, and then the encryption master key pair is stem:[( ke ,P_( pub - e))]. The EKGC keeps stem:[ke] secret and makes stem:[P_( pub - e)] public.

The EKGC chooses a one-byte encryption private key generating function identifier stem:[hid] and makes it public.

==== Generation Of Users' Encryption Private Key

Let stem:[ID_A] and stem:[ID_B] denote the identities of the users A and B respectively.

To generate the encryption private key stem:[de_A] of A, the EKGC first computes stem:[t_1 = H_1(ID_A ∥ hid ,N) + ke] over the finite field stem:[F_N]. If stem:[t_1 = 0], it regenerates the encryption master private key, computes the encryption master public key and makes it public, and updates the existing encryption private keys of users. Otherwise, it computes stem:[t_2 = ke * t_1^( - 1)], and then computes stem:[de_A = \[t_2\]P_2].

To generate the encryption private key stem:[de_B] of B, the EKGC first computes stem:[t_3 = H_1(ID_B ∥ hid ,N) + ke] over the finite field stem:[F_N]. If stem:[t_3 = 0], it regenerates the encryption master private key, computes the encryption master public key and makes it public, and updates the existing encryption private keys of users. Otherwise, it computes stem:[t_4 = ke * t_3^( - 1)], and then computes stem:[de_B = \[t_4\]P_2].


=== Key Exchange Protocol

Assume that the users A and B are negotiating a bit string of length stem:[klen], where A is the initiator and B is the responder.

In order to obtain the same keys, both A and B shall perform the following steps.

==== Initiation: User A:

A1: Compute the element stem:[Q_B = \[H_1(ID_B ∥ hid ,N)\]P_1 + P_( pub - e)] over stem:[G_1];

A2: Generate a random number stem:[r_A in \[1,N - 1\]];

A3: Compute the element stem:[R_A = \[r_A\]Q_B] over stem:[G_1];

A4: Send stem:[R_A] to B;

==== Response: User B

B1: Compute the element stem:[Q_A = \[H_1(ID_A ∥ hid ,N)\]P_1 + P_( pub - e)] over stem:[G_1];

B2: Generate a random number stem:[r_B in \[1,N - 1\]];

B3: Compute the element stem:[R_B = \[r_B\]Q_A] over stem:[G_1];

B4: Verify stem:[R_A in G_1] as specified in Clause 4.5 of <<GMT-0044.1-2016>>. If not, the protocol fails. Otherwise, compute over stem:[G_T]: stem:[g_1 = e(R_A, de_B)], stem:[g_2 = e(P_( pub - e),P_2)^(r_B)], stem:[g_3 = g_1^(r_B)]. Convert the data type of stem:[g_1], stem:[g_2], stem:[g_3] to bit string as specified in Clauses6.2.8 and 6.2.5 of <<GMT-0044.1-2016>>.

B5: Convert the data type of stem:[R_A] and stem:[R_B] to bit string as specified in Clauses 6.2.6 and 6.2.5 of <<GMT-0044.1-2016>>, and compute stem:[SK_B = KDF(ID_A ∥ ID_B ∥ R_A ∥ R_B ∥ g_1 ∥ g_2 ∥ g_3, klen )].

B6: (Optional) Compute stem:[S_B = H_v(0x82 ∥ g_1 ∥ H_v(g_2 ∥ g_3 ∥ ID_A ∥ ID_B ∥ R_A ∥ R_B))].

B7: Send stem:[R_B] and (optionally) stem:[S_B] to A.

==== Completion: User A

A5: Verify stem:[R_B in G_1] as specified in Clause 4.5 of <<GMT-0044.1-2016>>. If not, the protocol fails. Otherwise, compute over stem:[G_T]: stem:[g_1^' = e(P_( pub - e),P_2)^(r_A)], stem:[g_2^' = e(R_B, de_A)], stem:[g_3^' = (g_2^')^(r_A)]. Convert the data type of stem:[g_1^'], stem:[g_2^'], stem:[g_3^'] to bit string as specified in Clauses6.2.6 and 6.2.5 of <<GMT-0044.1-2016>>.

A6: Convert the data type of stem:[R_A] and stem:[R_B] to bit string as specified in Clauses 6.2.8 and 6.2.5 of <<GMT-0044.1-2016>>, and (optionally) compute stem:[S_1 = H_v(0x82 ∥ g_1^' ∥ H_v(g_2^' ∥ g_3^' ∥ ID_A ∥ ID_B ∥ R_A ∥ R_B))], and verify if stem:[S_1 = S_B], if not, the key confirmation from B to A fails.

A7: Compute stem:[SK_A = KDF(ID_A ∥ ID_B ∥ R_A ∥ R_B ∥ g_1^' ∥ g_2^' ∥ g_3^', klen )].

A8: (Optional) Compute stem:[S_A = H_v(0x83 ∥ g_1^' ∥ H_v(g_2^' ∥ g_3^' ∥ ID_A ∥ ID_B ∥ R_A ∥ R_B))] and send stem:[S_A] to B.

==== Confirmation: User B

B8: (Optional) Compute stem:[S_2 = H_v(0x83 ∥ g_1 ∥ H_v(g_2 ∥ g_3 ∥ ID_A ∥ ID_B ∥ R_A ∥ R_B))], and verify if stem:[S_2 = S_A], if not, the key confirmation from A to B fails.


==== Process Diagram

The process of the key exchange protocol is shown in Figure 1.
