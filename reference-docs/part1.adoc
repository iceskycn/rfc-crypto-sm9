= SM9 identity-based cryptographic algorithms, Part 1: General
:stem:

== Scope

This part describes fundamental mathematical knowledge and cryptographic techniques necessary for implementing cryptographic mechanisms provided in other parts of this standard.

This standard is applicable to the implementation, application and testing of commercial identity-based cryptographic algorithms.

This standard applies to the elliptic curves over the finite field stem:[F_p], where stem:[p] is a prime number that satisfies stem:[p > 2^(191)].

== Terms and definitions

=== identity

information that can be used to confirm the identity of an entity, composed of non-repudiable information about the entity, such as its distinguished name, email address, identity card number, and telephone number

=== master key

topmost key in the key hierarchy of an identity–based cryptographic system, composed of the master private key and master public key. The master public key is publicly available, while the master private key is preserved by the KGC in secrecy. A user's private key is generated by the KGC using the master private key and the user's identity. In an identity–based cryptographic system, the master private key is usually generated by the KGC using random number generators; the master public key is generated with the master private key and system parameters.

This standard specifies a different master key for the signature system than that of the encryption system. The master key of the digital signature algorithm, which belongs to the signature system, is the signature master key. The master key of the key exchange protocol, key encapsulation mechanism and public key encryption algorithm, which all belong to the encryption system, is the encryption master key.

=== key generation center (KGC)

trusted authority responsible for the selection of the system parameters, generation of master keys and generation of users' private keys within SM9 identity-based cryptographic algorithms

== Symbols and abbreviations

The following symbols and abbreviations apply to this part.

stem:[cf]:: cofactor of the order of an elliptic curve relative to stem:[N]

stem:[cid]:: curve identifier used to distinguish the type of elliptic curve used, denoted by one byte

DLP:: discrete logarithm problem over finite fields

stem:[deg (f)]:: the degree of the polynomial stem:[f(x)]

stem:[d_1,d_2]:: two divisors of stem:[k]

stem:[E]:: an elliptic curve over finite fields

ECDLP:: discrete logarithm problem over elliptic curves

stem:[E(F_q)]:: a set consisting of all rational points (including the point at infinity stem:[O]) of the elliptic curve stem:[E] over the finite field stem:[F_q]

stem:[E(F_q)\[r\]]:: the set of stem:[r]-torsion points in stem:[E(F_q)], that is the torsion subgroup of stem:[E(F_q)] of order stem:[r]

stem:[e]:: a bilinear pairing from stem:[G_1 xx G_2] to stem:[G_T]

stem:[eid]:: bilinear pairing identifier used to distinguish the type of bilinear pairing used, denoted by one byte

stem:[F_p]:: a prime field with stem:[p] elements

stem:[F_q]:: a finite field with stem:[q] elements

stem:[F_q^()]:: the multiplicative group composed of all the nonzero elements in stem:[F_q]

stem:[F_(q^m)]:: the stem:[m]-dimensional extension field of the finite field stem:[F_q]

stem:[G_T]:: a multiplicative cyclic group of prime order stem:[N]

stem:[G_1]:: an additive cyclic group of prime order stem:[N]

stem:[G_2]:: an additive cyclic group of prime order stem:[N]

stem:[gcd (x,y)]:: the greatest common divisor of stem:[x] and stem:[y]

stem:[k]:: the embedding degree of the curve stem:[E(F_q)] relative to stem:[N], where stem:[N] is a prime factor of stem:[E(F_q)]

stem:[m]:: the degree of the finite field extension stem:[F_(q^m) // F_q]

stem:[mod f(x)]:: the operation of modulo the polynomial stem:[f(x)]

stem:[mod n]:: the operation of modulo stem:[n], for example, stem:[23 mod 7 = 2]

stem:[N]:: the order of the cyclic groups stem:[G_1], stem:[G_2] and stem:[G_T], which is a prime number greater than stem:[2^(191)]

stem:[O]:: the point at infinity or the zero point on an elliptic curve, which is the identity element of the elliptic curve additive group

stem:[P]:: stem:[P = (x_P,y_P)] is a nonzero point on an elliptic curve, where its coordinates stem:[x_P] and stem:[y_P] satisfy the elliptic curve equation

stem:[P_1]:: a generator of stem:[G_1]

stem:[P_2]:: a generator of stem:[G_2]

stem:[P + Q]:: addition of two points stem:[P] and stem:[Q] on the elliptic curve E

stem:[p]:: a prime number greater than stem:[2^(191)]

stem:[q]:: the number of elements in the finite field stem:[F_q]

stem:[x_P]:: the stem:[x]-coordinate of point stem:[P]

stem:[x || y]:: the concatenation of stem:[x] and stem:[y], where stem:[x] and stem:[y] are bit strings or byte strings

stem:[x -= y( mod q)]:: stem:[x] and stem:[y] are congruent modulo stem:[q], that is stem:[x mod q = y mod q]

stem:[y_P]:: the stem:[y]-coordinate of point stem:[P]

stem:[E(K)]:: the number of points in stem:[E(K)], also called the order of the elliptic curve group stem:[E(K)], where stem:[K] is a finite field (including stem:[F_q] and stem:[F_(q^k)])

stem:[(: P :)]:: the cyclic group generated by the point stem:[P] on an elliptic curve

stem:[\[u\]P]:: the stem:[u] multiple of a point stem:[P] on an elliptic curve

stem:[\[x,y\]]:: the set of integers which are not less than stem:[x] and not greater than stem:[y]

stem:[|~ x ~|]:: ceiling function that maps to the smallest integer not less than stem:[x], for example, stem:[|~ 7 ~| = 7], stem:[|~ 8.3 ~| = 9]

stem:[| __x__ |]:: floor function that maps to the largest integer not greater than stem:[x], for example, stem:[| __7__ | = 7], stem:[| __8.3__ | = 8]

stem:[\beta]:: twisted curve parameter

stem:[\Psi]:: a homomorphism from stem:[G_2] to stem:[G_1] satisfying stem:[P_1 = \Psi (P_2)]

stem:[o+]:: the bitwise XOR operator that operates on two bit strings of the same length

=== Finite field and elliptic curve

==== Finite field

==== Overview

A field consists of a non-empty set stem:[F] with two operations: the addition (denoted by " stem:[+]") and the multiplication (denoted by " stem:[*]").

It satisfies following properties:

. stem:[\[\[F, + \],\[\]\]] is an additive abelian group, in which 0 denotes the identity element.
. stem:[\[\[\],\[(F { 0 } , * )\]\]] is a multiplicative abelian group, in which 1 denotes the identity element.
. Distributive law: stem:[(a + b)c = ac + bc] for all stem:[a,b,c in F].

If stem:[F] is a finite set, then the field is called a finite field. The number of elements in the finite field is called the order of the finite field.

=== Prime field stem:[F_p]

When the order of a finite field is prime, we call the field a prime field.

Let stem:[p] be a prime number, then the residue of integers modulo stem:[p], stem:[{ 0,1, ... p - 1 }], with respect to the addition modulo stem:[p] and the multiplication modulo stem:[p] can construct a prime field of order stem:[p], denoted by stem:[F_p].

stem:[F_p] has the following properties:

. the additive identity element is 0.
. the multiplicative identity element is 1.
. the addition of field elements is that of integers modulo stem:[p], namely, if stem:[a,b in F_p], then stem:[a + b = (a + b) mod p].
. the multiplication of field elements is that of integers modulo stem:[p], namely, if stem:[a,b in F_p], then stem:[a * b = (a * b) mod p].

=== Finite field stem:[F_(q^m)]

Let stem:[q] be a prime or a prime power, stem:[f(x)] be an stem:[m]-degree ( stem:[m > 1]) irreducible polynomial (reduced polynomial or field polynomial) in the polynomial ring stem:[F_q\[x\]], quotient ring stem:[F_q\[x\] // (f(x))] be a finite field with stem:[q^m] elements (denoted by stem:[F_(q^m)] ), then stem:[F_(q^m)] is the extension field of stem:[F_q], stem:[F_q] is the subfield of stem:[F_(q^m)], and stem:[m] is the extension degree. stem:[F_(q^m)] can be seen as the stem:[m]-dimensional vector space of stem:[F_q] and its elements can be uniquely represented by stem:[a_0 \beta_0 + a_1 \beta_1 + ... a_(m - 1) \beta_(m - 1), where a_i in F_q], stem:[\beta_0, ... , \beta_(m - 1)] is a base of stem:[F_(q^m)] over stem:[F_q] == .

The elements of stem:[F_(q^m)] can be represented via polynomial basis or normal basis. In this standard, unless otherwise specified, all elements of stem:[F_(q^m)] are represented by polynomial basis.

Choose a monic irreducible polynomial stem:[f(x) = x^m + f_(m - 1)x_(m - 1) + ... + f_2x^2 + f_1x + f_0(f_i in F_q,i = 0,1, ... ,m - 1)], then stem:[F_(q^m)] is composed of all polynomials in the polynomial ring stem:[F_q\[x\]] of degree less than stem:[m]. The set of polynomials stem:[{ x^(m - 1),x^(m - 2), ... ,x,1 }] is a base for stem:[F_(q^m)] over stem:[F_q], which is called a polynomial basis. For any element stem:[a(x) = a_(m - 1)x^(m - 1) + a_(m - 2)x^(m - 2) + ... + a_1x + a_0] in stem:[F_(q^m)], its coefficients over stem:[F_q] constitute an stem:[m]-dimensional vector, denoted by stem:[a = (a_(m - 1),a_(m - 2), ... ,a_1,a_0)], where stem:[a_i in F_q,i = 0,1, ... ,m - 1].

stem:[F_(q^m)] has the following properties:

. The zero element 0 is represented by an stem:[m]-dimensional vector stem:[(0,0, ... 0,0,0)].

. The multiplicative identity element is represented by an stem:[m]-dimensional vector stem:[(0,0, ... 0,0,1)].

. The addition of two field elements is the addition of vectors, and each vector component adopts addition of field stem:[F_q].

. The multiplication of elements stem:[a] and stem:[b] is defined like this: let stem:[a] and stem:[b] correspond to the polynomials stem:[a(x)] and stem:[b(x)] over stem:[F_q] respectively; then, stem:[a * b] is defined as the corresponding vector of the polynomial stem:[(a(x) * b(x)) mod f(x)].

. The inverse element: suppose stem:[a(x)] is the corresponding polynomial of stem:[a] over stem:[F_q], stem:[a^( - 1)(x)] is the corresponding polynomial of stem:[a^( - 1)] over stem:[F_q], such that stem:[a(x) * a^( - 1)(x) = 1 mod f(x)].

See Annex A.1 for more details about stem:[F_(q^m)].

=== Elliptic curves over finite field

The elliptic curve over finite field stem:[F_(q^m)] ( stem:[m >= 1]) is a set of points. A point stem:[P] (except the point stem:[O]) on the elliptic curve can be represented by the coordinates stem:[P = (x_P,y_P)], where stem:[x_P] and stem:[y_P] are field elements satisfying a certain equation, and are called the stem:[x]-coordinate and stem:[y]-coordinate, respectively.

This part describes elliptic curves whose characteristic is a large prime stem:[p].

In this part, the points on an elliptic curve are represented by affine coordinates, unless otherwise specified.

The equation of elliptic curves defined over stem:[F_(q^m)] is:

|===
<.^h|
stem:[y^2 = x^3 + ax + b,a,b in F_(p^m), ^^ 4a^3 + 27b^2 != 0] .

 <.^a|
. (1)

|===

The elliptic curve stem:[E(F_(q^m))] is defined as:

stem:[E(F_(q^m)) = {(x,y) | (x,y in F)_(q^m)], satisfying the equation stem:[(1) uu {O}], where stem:[O] is the point at stem:[oo].

The number of points on the elliptic curve stem:[E(F_(q^m))] is represented by stem:[E(F_(q^m))], which is also called the order of stem:[E(F_(q^m))].

This standard requires the prime stem:[p > 2^(191)].

Let stem:[E] and stem:[E'] be elliptic curves defined over stem:[F_q]. If there exists an isomorphic map stem:[\varphi_d : E'(F_(q^d)) -> E(F_(q^d))], where stem:[d] is the smallest integer which makes the map exist, then stem:[E'] is called the degree stem:[d] twisted curve of stem:[E]. There are three cases of the value of stem:[d] when stem:[p >= 5]:

. If stem:[a = 0,b != 0], then stem:[d = 6], and stem:[E^' : y^2 = x^3 + \betab], stem:[\varphi_6 : E^' -> E : (x,y) |-> ( \beta^( - 1 // 3)x, \beta^( - 1 // 2)y)].

. If stem:[b = 0,a != 0], then stem:[d = 4], and stem:[E^' : y^2 = x^3 + \betaax], stem:[\varphi_4 : E^' -> E : (x,y) |-> ( \beta^( - 1 // 2)x, \beta^( - 3 // 4)y)].

. If stem:[a != 0,b != 0], then stem:[d = 2], and stem:[E^' : y^2 = x^3 + \beta^2 ax + \beta^3b], stem:[\varphi_2 : E^' -> E : (x,y) |-> ( \beta^( - 1)x, \beta^( - 3 // 2)y)].

=== Elliptic curve group

The points on elliptic curve stem:[E(F_(q^m))], where stem:[(m >= 1)], constitute an abelian group based on the following addition operation rules:

. stem:[O + O = O].

. stem:[\[\[\],\[AAP = (x,y) in E(F_(q^m)) { O } \]\]], stem:[P + O = O + P = P].

. stem:[\[\[\],\[AAP = (x,y) in E(F_(q^m)) { O } \]\]], the inverse element of stem:[P] is stem:[– P = (x, - y)], and stem:[P + ( - P) = O].

. The addition rules for two different points (wherein these points are not the inverse of each other):
Let stem:[\[\[\],\[P_1 = (x_1,y_1) in E(F_(q^m)) { O } \]\]]_,_ stem:[\[\[\],\[P_2 = (x_2,y_2) in E(F_(q^m)) { O } \]\]], and stem:[x_1 != x_2].

Let stem:[P_3 = (x_3,y_3) = P_1 + P_2], then

stem:[{\[\[x_3 = \lambda^2 - x_1 - x_2,\],\[y_3 = \lambda (x_1 - x_3) - y_1,\]\]]

where

stem:[\lambda = (y_2 - y_1)/(x_2 - x_1) .]

. Point doubling:

Let stem:[\[\[\],\[P_1 = (x_1,y_1) in E(F_(q^m)) { O } \]\]], and stem:[y_1 != 0]_,_ stem:[P_3 = (x_3,y_3) = P_1 + P_1], then

stem:[{\[\[x_3 = \lambda^2 - 2x_1,\],\[y_3 = \lambda (x_1 - x_3) - y_1,\]\]]

where

stem:[\lambda = (3x_1^2 + a)/(2y_1)].

=== Scalar multiplication on elliptic curve

The repeated addition of the same point is called the scalar multiplication of the point. Let stem:[u] be a positive integer, stem:[P] be a point on the elliptic curve, then the stem:[u] multiple of the point stem:[P] is denoted by stem:[Q = \[u\]P = underset(uP's)(ubrace (P + P + ... + P))].

Scalar multiplication can be extended to 0-multiple and negative-multiple operations: stem:[\[0\]P = O], stem:[\[- u\]P = \[u\]( - P)].

Scalar multiplication can be calculated efficiently using certain techniques; please refer to Annex A.2 for them.

=== Verification of points in a subgroup of an elliptic curve

Input:: The parameters stem:[a] and stem:[b] which define the elliptic curve equation over stem:[F_(q^m)], where stem:[q] is an odd prime and stem:[m >= 1], the order stem:[N] of the subgroup stem:[G] of the elliptic curve stem:[E(F_(q^m))], a pair of elements in stem:[F_(q^m)] stem:[(x,y)].

Output:: If stem:[(x,y)] is an element of the group stem:[G], then output "valid", otherwise output "invalid".

. Check if stem:[(x,y)] satisfies the equation of the elliptic curve stem:[y^2 = x^3 + ax + b].
. Let stem:[Q = (x,y)], check if stem:[\[N\]Q = O].

If any of these above verification fail, output "invalid", otherwise output "valid".

=== Discrete logarithm problem

==== Discrete logarithm problem over finite field

The set of all nonzero elements in stem:[F_(q^m)] ( stem:[q] is an odd prime, stem:[m >= 1]) forms a multiplicative cyclic group, denoted by stem:[F_(q^m)^()]. An element stem:[g in F_(q^m)^()] is called a generator if it satisfies stem:[F_(q^m)^() = {g^i || 0 <= i <= q^m - 2}]. The minimal integer stem:[t] such that stem:[a^t = 1] is called the order of stem:[a] in stem:[F_(q^m)^()]. The order of stem:[F_(q^m)^()] is stem:[q^m - 1], so stem:[t || q^m - 1].

Suppose the generator of stem:[F_(q^m)^()] is stem:[g], stem:[y in F_(q^m)^()], the discrete logarithm problem over a finite field is to find the integer stem:[x in \[0,q^m - 1\]] such that stem:[y = g^x] in stem:[F_(q^m)^()].

==== Elliptic curve discrete logarithm problem (ECDLP)

For an elliptic curve stem:[E(F_(q^m))] ( stem:[m >= 1]), the point stem:[P in E(F_(q^m))] of order stem:[n] and stem:[Q in (: P :)], ECDLP is to find stem:[l in \[0,n - 1\]] satisfying stem:[Q = \[l\]P].

== Bilinear pairings and secure curves

=== Bilinear pairings

Let stem:[\[\[G\],\[\],\[\],\[\]\]], stem:[\[\[G\],\[\],\[\],\[\]\]] and stem:[\[\[G\],\[(T, * )\],\[\]\]] be three cyclic groups. The order of stem:[G_1], stem:[G_2] and stem:[G_T] is a prime stem:[N], stem:[P_1] is a generator of stem:[G_1], stem:[P_2] is a generator of stem:[G_2], and there exists a homomorphism stem:[\psi] from stem:[G_2] to stem:[G_1] such that stem:[\psi (P_2) = P_1].

Bilinear pairing stem:[e] is a map of stem:[G_1 xx G_2 -> G_T] satisfying the following conditions:

. Bilinearity: for any stem:[P in G_1], stem:[Q in G_2], stem:[(a,b in Z)_N], stem:[e(\[a\]P,\[b\]Q) = e(P,Q)^( ab )].

. Non-degeneracy: stem:[e(P_1,P_2) != 1_(G_T)].

. Computability: for any stem:[P in G_1], stem:[Q in G_2], there exists an efficient algorithm to compute stem:[e(P,Q)].

Bilinear pairings used in this part are defined on elliptic curve groups, such as the Weil pairing, the Tate pairing, the Ate pairing and the R-ate pairing.


=== Security

The security of bilinear pairings is based on the following hard problems:

Problem 1 (Bilinear Inverse Diffie-Hellman Problem, BIDH)::
For stem:[a,b in \[1,N - 1\]], given stem:[\[a\]P_1,\[b\]P_2],
it is hard to compute stem:[e(P_1,P_2)^(b // a)].

Problem 2 (Decisional Bilinear Inverse Diffie-Hellman Problem, DBIDH)::
For stem:[a,b,r in \[1,N - 1\]], it is hard to distinguish
stem:[(P_1,P_2,\[a\]P_1,\[b\]P_2,e(P_1,P_2)^(b // a))]
from stem:[(P_1,P_2,\[a\]P_1,\[b\]P_2,e(P_1,P_2)^r)].

Problem 3 (stem:[\tau]-Bilinear Inverse Diffie-Hellman Problem, stem:[\tau]-BDHI)::
For integer stem:[\tau] and stem:[x in \[1,N - 1\]],
given stem:[(P_1,\[x\]P_1,P_2,\[x\]P_2,\[x^2\]P_2, ... ,\[x^( \tau )\]P_2)],
it is hard to compute stem:[e(P_1,P_2)^(1 // x)].

Problem 4 (stem:[\tau]*-Gap-Bilinear Inverse Diffie-Hellman Problem, stem:[\tau]*-Gap-BDHI)::
For integer stem:[\tau] and stem:[x in \[1,N - 1\]],
given stem:[(P_1,\[x\]P_1,P_2,\[x\]P_2,\[x^2\]P_2, ... ,\[x^( \tau )\]P_2)]
and the DBIDH algorithm, it is hard to compute stem:[e(P_1,P_2)^(1 // x)].

The security of the SM9 identity-based cryptographic algorithms is founded on the computational intractability of the above problems. The hardness of these problems implies that the discrete logarithm problems over stem:[G_1], stem:[G_2], and stem:[G_T] are also intractable; and when selecting an elliptic curve the primary consideration is to ensure the discrete logarithm problems remain intractable on the selected curve.

=== Embedding degrees and secure curves

Let stem:[G] be an stem:[N]-order subgroup of the elliptic curve stem:[E(F_q)]. The smallest positive integer stem:[k] such that stem:[N || q^k - 1] is called the embedding degree of stem:[G] relative to stem:[N], also known as the embedding degree of stem:[E(F_q)] relative to stem:[N].

Let stem:[G_1] be an stem:[N]-order subgroup of stem:[E(F_(q^(d_1)))], where stem:[d_1 || k], and stem:[G_2] be an stem:[N]-order subgroup of stem:[E(F_(q^(d_2)))], where stem:[d_2 || k], then the range stem:[G_T] of the bilinear pairings based on the elliptic curves is a subgroup of stem:[F_(q^k)^()]. Thus, the bilinear pairings based on the elliptic curves can convert the elliptic curve discrete logarithm problem to the discrete logarithm problem over the finite field stem:[F_(q^k)^()]. The security of the curve improves as the size of the extension field increases (if no faster discrete logarithm algorithm exists in the field), yet it becomes harder to compute the bilinear pairings. Hence it is necessary to adopt an elliptic curve with an appropriate embedding degree while achieving the desired security level. This standard specifies that stem:[q^k > 2^(1536)].

This standard specifies the use of the following curves:
. Ordinary curves whose base field is stem:[F_q], where stem:[q] is a prime greater than stem:[2^(191)], and the embedding degree stem:[k = 2^i3^j], where stem:[i > 0] and stem:[j >= 0].
. Supersingular curves whose base field is stem:[F_q], where stem:[q] is a prime greater than stem:[2^(768)], and the embedding degree stem:[k = 2].

For stem:[N] less than stem:[2^(360)], it is recommended that:

. stem:[N - 1] has a prime factor greater than stem:[2^(190)]
. stem:[N + 1] has a prime factor greater than stem:[2^(120)]

== Data types and conversions

=== Data type

The data types include bit string, byte string, field element, elliptic curve point and integer in this standard.

Bit string::
an ordered sequence of 0's and 1's.

Byte string::
an ordered sequence of bytes, where one byte contains 8 bits and the leftmost bit is the most significant bit.

Field element::
the elements of finite field stem:[F_(q^m)] ( stem:[m >= 1]).

Elliptic curve point::
a point stem:[P in E(F_(q^m))(m >= 1)] is either a pair of field elements stem:[(x_P,y_P)], where stem:[x_P,y_P] satisfy the ecliptic curve equation, or the point at infinity stem:[O].

A point can be encoded as a byte string in many forms. A byte _PC_ is used to indicate which form is used. The byte string representation of the point at infinity stem:[O] is a unique zero byte stem:[PC = 00].

A nonzero point stem:[P = (x_P,y_P)] can be represented as one of the following three byte string forms:

. Compressed form, stem:[PC = 02] or stem:[03];
. Uncompressed form, stem:[PC = 04];
. Hybrid form, stem:[PC = 06] or stem:[07].

NOTE: The hybrid form contains both the compressed and uncompressed forms. In implementation, the hybrid form can be converted into the compressed or uncompressed forms. Implementation of the compressed and hybrid forms are optional in this standard. Please refer to Annex A.4 for the details of the compressed form.


=== Data type conversions

==== Conversion relations between data types

Figure 1 indicates the conversion relations between the data types. The subclauses for the corresponding conversion methods are given by the marks along the lines.

==== Conversion of an integer to a byte string

Input:: a non-negative integer stem:[x], and the target length of the byte string stem:[l] (where stem:[l] satisfies stem:[2^(8l) > x]).

Output:: a byte string stem:[M] of stem:[l] bytes long.

. Let stem:[M_(l - 1),M_(l - 2), ... ,M_0] be the individual bytes of stem:[M] from left to right.
. The bytes of stem:[M] satisfy: stem:[x = sum_(i = 0)^(l - 1)2^(8i)M_i .]

==== Conversion of a byte string to an integer

Input:: a byte string stem:[M] of stem:[l] bytes long.

Output:: an integer stem:[x].


. Let stem:[M_(l - 1),M_(l - 2), ... ,M_0] be the individual bytes of stem:[M] from left to right.

. Convert stem:[M] to the integer stem:[x]:

stem:[x = sum_(i = 0)^(l - 1)2^(8i)M_i .]

==== Conversion of a bit string to a byte string

Input:: a bit string stem:[s] of stem:[n] bits long.

Output:: a byte string stem:[M] of stem:[l] bytes long, where stem:[l = |~ n // 8 ~|].


. Let stem:[s_(n - 1),s_(n - 2), ... ,s_0] be the individual bits of stem:[s] from left to right.

. Let stem:[M_(l - 1),M_(l - 2), ... ,M_0] be the individual bytes of stem:[M] from left to right, then

stem:[M_i = s_(8i + 7)s_(8i + 6) ... s_(8i + 1)s_(8i),where0 <= i < l,and when8i + j >= nand0 < j <= 7,s_(8i + j) = 0.]

==== Conversion of a byte string to a bit string

Input:: a byte string stem:[M] of stem:[l] bytes long.

Output:: a bit string stem:[s] of stem:[n] bits long, where stem:[n = 8l].


. Let stem:[M_(l - 1),M_(l - 2), ... ,M_0] be the individual bytes of stem:[M] from left to right.

. Let stem:[s_(n - 1),s_(n - 2), ... ,s_0] be the individual bits of stem:[s] from left to right, then stem:[s_i] ==
is the stem:[(i - 8j + 1)] == th
 bit of stem:[M_j] ==
from the right, where stem:[j = | __i // 8__ |].

==== Conversion of a field element to a byte string

Input:: an element stem:[\alpha = ( \alpha_(m - 1), \alpha_(m - 2), ... , \alpha_1, \alpha_0)] in stem:[F_(q^m)(m >= 1),] and stem:[q = p].

Output:: a byte string stem:[s] of length stem:[l], where stem:[l = |~ log_2q // 8 ~| xx m].

. If stem:[m = 1], then stem:[\alpha = \alpha_0(q = p)], stem:[\alpha] is an integer in stem:[\[0,q - 1\]], convert stem:[\alpha] to a byte string stem:[S] of stem:[l] bytes long as specified in 6.2.2.

. If stem:[m > 1], then stem:[\alpha = ( \alpha_(m - 1), \alpha_(m - 2), ... , \alpha_1, \alpha_0)(q = p)], where stem:[\alpha_i in F_q,i = 0,1, ... ,m - 1].

 1) Let stem:[r = |~ log_2q // 8 ~|].

.. For stem:[i] from stem:[m - 1] to 0: +
Convert stem:[\alpha_i(q = p)]to a byte string stem:[s_i] of stem:[r] bytes long as specified in 6.2.2.

.. stem:[S = s_(m - 1) || s_(m - 2) || ... || s_0] == .

==== Conversion of a byte string to a field element

*Case 1: Convert to element in the base field*

Input:: a field stem:[F_q], stem:[q = p], and a byte string stem:[S] of stem:[l] bytes long, where stem:[l = |~ lo g_2q // 8 ~|].

Output:: an element stem:[\alpha] in stem:[F_q].

If stem:[q = p], convert stem:[S] to an integer stem:[\alpha] as specified in 6.2.3. If stem:[\alpha] is not in the range stem:[\[0,q - 1\]], report an error.

*Case 2: Convert to element in extension field*

Input:: a field stem:[F_(q^m)] ( stem:[m >= 2]), stem:[q = p], and a byte string stem:[S] of stem:[l] bytes long, where stem:[l = |~ lo g_2q // 8 ~| xx m].

Output:: an element stem:[\alpha] in stem:[F_(q^m)].


. Equally divide the byte string stem:[S] into stem:[m] parts, where the length of each part is stem:[l // m] bytes long, denote it as stem:[S = (S_(m - 1),S_(m - 2), ... ,S_1,S_0)].

. For stem:[i] from stem:[m - 1] to 0:

Convert stem:[S_i] to an integer stem:[\alpha_i] as specified in 6.2.3, and if stem:[\alpha] is not in stem:[\[0,q - 1\]], report an error.


. If stem:[q = p], output stem:[a = (a_(m - 1),a_(m - 2), ... ,a_1,a_0)].

==== Conversion of a point to a byte string

There are two cases in the conversion of a point to a byte string.

The first case is that in the computation process, convert the elliptic curve point to a byte string before setting it as the input of some function (e.g., a hash function). In this case, we only need to convert the point to byte string.

The second case is when transmitting or storing elliptic curve points, in order to reduce the transmission quantity or storage space, we can use the compressed or the hybrid compressed form of the points. In such case, we need to add an identifier stem:[PC] to indicate the encoding form of the point.

The details of the two cases of conversion are as follows.

*Case 1*: *Direct conversion*

Input:: a point stem:[P = (x_P,y_P)] on the elliptic curve stem:[E(F_(q^m))], where stem:[P != O].

Output:: a byte string stem:[X_1 || Y_1] of stem:[2l] bytes long. (If stem:[m = 1], stem:[l = |~ log_2q // 8 ~|]; if stem:[m > 1], stem:[l = |~ log_2q // 8 ~| xx m].)


. Convert the field element stem:[x_P] to the byte string stem:[X_1] of stem:[l] bytes long as specified in 6.2.6;

. Convert the field element stem:[y_P] to the byte string stem:[Y_1] of stem:[l] bytes long as specified in 6.2.6;

. Output the byte string stem:[X_1 || Y_1].

*Case 2: Conversion by adding a byte string identifier* stem:[PC]

Input:: a point stem:[P = (x_P,y_P)] on the elliptic curve stem:[E(F_(q^m))], where stem:[P != O].

Output:: a byte string stem:[PO]. If the uncompressed form or the hybrid form is used, output a byte string of length stem:[2l + 1]; if the compressed form is used, output a byte string of stem:[l + 1] bytes long. (If stem:[m = 1], stem:[l = |~ log_2q // 8 ~|]; if stem:[m > 1], stem:[l = |~ log_2q // 8 ~| xx m].)


. Convert the field element stem:[x_P] to the byte string stem:[X_1] of stem:[l] bytes long as specified in 6.2.6;


. If the compressed form is used, then

.. Compute the bit stem:[overset(tilde)(y)_P]. (See Annex A.4.)

.. If stem:[overset(tilde)(y)_P = 0], then let stem:[PC = 02]; if stem:[overset(tilde)(y)_P]=1, stem:[PC = 03];

.. Output the byte string stem:[PO = PC || X_1].


. If the uncompressed form is used, then

.. Convert the field element stem:[y_P] to the byte string stem:[Y_1] of stem:[l] bytes long as specified in 6.2.6;

.. Let stem:[PC = 04];

.. Output the byte string stem:[PO = PC || X_1 || Y_1].


. If the hybrid form is used, then

.. Convert the field element stem:[y_P] to the byte string stem:[Y_1] of stem:[l] bytes long as specified in 6.2.6;

.. Compute the bit stem:[overset(tilde)(y)_P]; (See Annex A.4.)

.. If stem:[overset(tilde)(y)_P = 0], then let stem:[PC = 06]; if stem:[overset(tilde)(y)_P = 1], stem:[PC = 07];

.. Output the byte string stem:[PO = PC || X_1 || Y_1].

==== Conversion of a byte string to a point

The conversion of a byte string to a point is the inverse process of 6.2.8. The conversion is explained in the following two cases.

*Case 1: Direct conversion*

Input:: field elements stem:[a] and stem:[b] which define an elliptic curve over stem:[F_(q^m)] ( stem:[m >= 1]), and the byte string stem:[X_1 || Y_1] of length stem:[2l] bytes long. The lengths of both stem:[X_1] and stem:[Y_1] are stem:[l] bytes. (If stem:[m = 1], stem:[l = |~ log_2q // 8 ~|]; if stem:[m > 1], stem:[l = |~ log_2q // 8 ~| xx m].).

Output:: a point stem:[P = (x_P,y_P)] of the elliptic curve, where stem:[P != O].


. Convert the byte string stem:[X_1] to a field element stem:[x_P] as specified in 6.2.7;

. Convert the byte string stem:[Y_1] to a field element stem:[y_P] as specified in 6.2.7;

*Case 2: Conversion of a byte string containing the byte identifier* stem:[PC]

Input:: field elements stem:[a] and stem:[b] which define an elliptic curve over stem:[F_(q^m)] ( stem:[m >= 1]), and the byte string stem:[PO]. If the uncompressed or hybrid forms are used, the length of stem:[PO] is stem:[2l + 1] bytes long. If the compressed form is used, the length of stem:[PO] is stem:[l + 1] bytes long. (If stem:[m = 1], then stem:[l = |~ log_2q // 8 ~|]; if stem:[m > 1], then stem:[l = |~ log_2q // 8 ~| xx m].)

Output:: a point stem:[P = (x_P,y_P)] of the elliptic curve, where stem:[P != O].


. If the compressed form is used, then stem:[PO = PC || X_1]; if the uncompressed or hybrid forms are used, stem:[PO = PC || X_1 || Y_1], where stem:[PC] is a single byte, and both stem:[X_1] and stem:[Y_1] are byte strings of stem:[l] bytes long;

. Convert the byte string stem:[X_1] to a field element stem:[x_P] as specified in 6.2.7;

. If the compressed form is used, then

.. Check whether stem:[PC = 02] or stem:[PC = 03]; if not, report an error;

.. If stem:[PC = 02], then let stem:[overset(tilde)(y)_P = 0]; if stem:[PC = 03], let stem:[overset(tilde)(y)_P = 1];

.. Convert stem:[(x_P,overset(tilde)(y)_P)] to a point stem:[(x_P,y_P)] on the elliptic curve; (See Annex A.4.)


. If the uncompressed form is used, then

.. Check whether _PC_ = 04; if not, report error;

.. Convert the byte string stem:[Y_1] to a field element stem:[y_P] as specified in 6.2.7;


. If the hybrid form is used, then

.. Check whether stem:[PC = 06] or stem:[PC = 07]; if not, report an error;

.. Perform e.2.1) or e.2.2):

Convert the byte string stem:[Y_1] to a field element stem:[y_P] as specified in 6.2.7;

If stem:[PC = 06], then let stem:[overset(tilde)(y)_P = 0], otherwise let stem:[overset(tilde)(y)_P = 1]; convert stem:[(x_P,overset(tilde)(y)_P)] to a point stem:[(x_P,y_P)] on the elliptic curve; (See Annex A.4.)


. Check whether stem:[(x_P,y_P)] satisfies the equation of the curve; if not, report an error;

. stem:[P = (x_P,y_P)].


== System parameters and parameters verification

=== System parameters

The system parameters include:

. The curve identifier stem:[cid] is denoted by one byte: 0x10 represents an ordinary curve over stem:[F_q] (where the prime number stem:[q > 3]), 0x11 represents a supersingular curve over stem:[F_q], and 0x12 represents an ordinary curve and the corresponding twisted curve over stem:[F_q];

. The parameter of the base field stem:[F_q] ==
of the elliptic curve: the parameter of the base field is a prime number stem:[q > 3];

. Two elements stem:[a] and stem:[b] in stem:[F_q], which define the equation of the elliptic curve stem:[E : y^2 = x^3 + ax + b]; the twisted curve parameter stem:[\beta] (if the least 4 significant bits of stem:[cid] is 2);

. The cofactor stem:[cf] and a prime number stem:[N], where stem:[cf xx N = E(F_q)]. <<GMT-0044-2016>> requires stem:[N > 2^(191)] and stem:[N] is not divisible by stem:[cf]. If stem:[N < 2^(360)], <<GMT-0044-2016>> recommends that stem:[N - 1] has prime factors greater than stem:[2^(190)] and stem:[N + 1] has prime factors greater than stem:[2^(120)];

. The embedding degree stem:[k] of the curve stem:[E(F_q)] relative to stem:[N]. (The cyclic group with order stem:[(G_T, * ) sub F_(q^k)^()]). <<GMT-0044-2016>> specifies that stem:[q^k > 2^(1536)];

. A generator stem:[P_1 = (x_(P_1),y_(P_1))] of the cyclic group stem:[\[\[G_1, + \],\[\]\]], where stem:[P_1 != O];

. A generator stem:[P_2 = (x_(P_2),y_(P_2))] of the cyclic group stem:[\[\[G_2, + \],\[\]\]], where stem:[P_2 != O];

. The bilinear pairing stem:[e : G_1 xx G_2 -> G_T] is denoted by one byte identifier stem:[eid]: 0x01 represents the Tate pairing, 0x02 represents the Weil pairing, 0x03 represents the Ate pairing, and 0x04 represents the R-ate pairing;

. (Optional) The parameters stem:[d_1], stem:[d_2], both of which are factors of stem:[k];

. (Optional) The homomorphism stem:[\Psi] from stem:[G_2] to stem:[G_1] such that stem:[P_1 = \Psi (P_2)];

. (Optional) The characteristic of the base field of the BN curves, the order of curve stem:[r], and the trace of the Frobenius map which can be determined by the parameter stem:[t], where stem:[t] is at least 63 bits long.


=== Verification of the system parameters

The following conditions shall be verified by the generator of the system parameters. They can also be verified by the users of the system parameters.

Input:: the set of the system parameters.

Output:: if all parameters are valid, output "valid"; otherwise output "invalid".

. Verify that stem:[q] is a prime greater than 3; (See Annex C.1.5.)

. Verify that stem:[a,b] are integers in stem:[\[0,q - 1\]];

. Verify that stem:[4a^3 + 27b^2 != 0] over stem:[F_q]; if the least 4 significant bits of stem:[cid] are 2, verify that stem:[\beta] is a non-square element; (See Annex C.1.4.3.1.)

. Verify that stem:[N] is a prime greater than stem:[2^(191)] and stem:[cf] is not divisible by stem:[N]; if stem:[N < 2^(360)], verify that stem:[N - 1] has prime factors greater than stem:[2^(190)] and stem:[N + 1] has prime factors greater than stem:[2^(120)];

. Verify that stem:[q + 1 - cf xx N || 2q^(1 // 2)];

. Verify that stem:[q^k > 2^(1536)] and stem:[k] is the smallest positive integer stem:[m] such that stem:[N || (q^m - 1)];

. Verify that stem:[(x_(P_1),y_(P_1))] is an element of stem:[G_1];

. Verify that stem:[(x_(P_2),y_(P_2))] is an element of stem:[G_2];

. Verify stem:[\[\[\],\[e(P_1,P_2) in F_(q^k)^() { 1 } \]\]], and stem:[e(P_1,P_2)^N = 1];

. (Optional) Verify stem:[d_1,d_2 || k];

. (Optional) Verify that stem:[P_1 = \Psi (P_2)];

If any of the above verification fails, output "invalid"; otherwise output "valid".


[appendix]
== Annex A (informative) Elliptic curve basics

=== Finite field


==== Prime field stem:[F_p]

Suppose stem:[p] is prime, then in the set of remainders stem:[{ 0,1,2,...,p - 1 }] modulo stem:[p], the addition and multiplication in terms of the arithmetic of integers modulo stem:[p] form a stem:[p]-order prime field, which is symbolized by stem:[F_p]. The additive identity is 0, while the multiplicative identity is 1. The elements of stem:[F_p] have the following operation rules:

* Addition: if stem:[a,b in F_p], then stem:[a + b = r], where stem:[r = (a + b) mod p], stem:[r in \[0,p - 1\]]. +
* Multiplication: if stem:[a,b in F_p], then stem:[a * b = s], where stem:[s = ( a*b ) mod p], stem:[s in \[0,p - 1\]].

Let stem:[F_p^()] be the multiplicative group composed of all nonzero elements of stem:[F_p]. Since stem:[F_p^()] is a multiplicative group, there is at least one element stem:[g] in stem:[F_p], satisfying that any nonzero element in stem:[F_p] can be represented by the power of stem:[g]. We call stem:[g] the generator (primitive element) of stem:[F_p^()], and stem:[F_p^() = {g^i|0 <= i <= p - 2 }]. Let stem:[a = g^i in F_p^()], and stem:[0 <= i <= p - 2], then the multiplicative inverse of stem:[a] is: stem:[a^( - 1) = g^(p - 1 - i)].

*Example 1:* the prime field stem:[F_(19) = { 0,1,2, ... ,18 }].

Example of addition in stem:[F_(19)]: stem:[10,14 in F_(19)], stem:[10 + 14 = 24], stem:[24 mod 19 = 5], then stem:[10 + 14 = 5].

Example of multiplication in stem:[F_(19)]: stem:[7,8 in F_(19)], stem:[7 xx 8 = 56], stem:[56 mod 19 = 18], then stem:[7 * 8 = 18].

13 is a generator of stem:[F_(19)^()], then the elements of stem:[F_(19)^()] can be represented by the powers of 13:

* stem:[13^0 = 1], stem:[13^1 = 13], stem:[13^2 = 17], stem:[13^3 = 12], stem:[13^4 = 4], stem:[13^5 = 14], stem:[13^6 = 11], stem:[13^7 = 10], stem:[13^8 = 16], stem:[13^9 = 18], stem:[13^(10) = 6], stem:[13^(11) = 2], stem:[13^(12) = 7], stem:[13^(13) = 15], stem:[13^(14) = 5], stem:[13^(15) = 8], stem:[13^(16) = 9], stem:[13^(17) = 3], stem:[13^(18) = 1].

==== Finite field stem:[F_(q^m)]

Suppose stem:[q] is a prime or a prime power, stem:[f(x)] be an stem:[m]-degree ( stem:[m > 1]) irreducible polynomial (which is called the reduced polynomial or the field polynomial) in the polynomial ring stem:[F_q\[x\]], the quotient ring stem:[F_q\[x\] // (f(x))] be a finite field composed of stem:[q^m]elements, then stem:[F_(q^m)]is an extension field of stem:[F_q], stem:[F_q]is a subfield of stem:[F_(q^m)], stem:[m] is the extension degree. stem:[F_(q^m)]can be seen as the stem:[m]-dimensional vector space of stem:[F_q], that is to say there exist stem:[m] elements stem:[\alpha_0, \alpha_1, ... , \alpha_(m - 1)] in stem:[F_(q^m)], such that stem:[AA \alpha in F_(q^m)], stem:[\alpha] can be uniquely represented by stem:[( \alpha = a_(m - 1) \alpha_(m - 1)( + cdots + a)_0 \alpha )_0 + a_1 \alpha_1] ( stem:[a_i in F_q]), then stem:[{ \alpha_0, \alpha_1, cdots , \alpha_(m - 1) }] is called a basis of stem:[F_(q^m)] over stem:[F_q]. Given such a basis, then we can use the vector stem:[(a_0,a_1, ... ,a_(m - 1))] to represent the field element stem:[\alpha].

There are many possible choices for the selection of a basis, such as the polynomial basis and the normal basis.

Suppose the irreducible polynomial stem:[f(x)] is a monic polynomial stem:[f(x) = x^m + f_(m - 1)x^(m - 1) + ... + f_2x^2 + f_1x + f_0] ( stem:[f_i in F_q], stem:[i = 0,1, ... ,m - 1]), and the elements of stem:[F_(q^m)] can be represented by all polynomials with degree less than stem:[m] in the polynomial ring stem:[F_q\[x\]], that is, stem:[F_(q^m) = {a_(m - 1)x^(m - 1) + a_(m - 2)x^(m - 2) + * * * + a_1x + a_0|a_i in F_q,i = 0,1,...,m - 1 }]. The set of polynomials stem:[{ x^(m - 1),x^(m - 2), ... ,x,1 }] is a basis of stem:[F_(q^m)] as a vector space over stem:[F_q], which is called a polynomial basis. When stem:[m] has a divisor stem:[d] ( stem:[1 < d < m]), stem:[F_(q^d)] could be extended to stem:[F_(q^m)]. If a suitable stem:[m // d]-degree irreducible polynomial is selected from stem:[F_(q^d)\[x\]] to act as stem:[F_(q^m)]'s reduced polynomial on stem:[F_(q^d)], then stem:[F_(q^m)]could be generated according to the towering method. This extension's basic forms are still vectors composed of the elements of stem:[F_q]. For example, when stem:[m = 6], stem:[F_q] ==
could be extended three times to the extension field stem:[F_(q^3)], and stem:[F_(q^3)] could be further extended twice to the extension field stem:[F_(q^6)]. stem:[F_q] ==
could be extended twice to the extension field stem:[F_(q^2)], and stem:[F_(q^2)]could be further extended three times to the extension field stem:[F_(q^6)].

The basis of the form stem:[{ \beta , \beta^q, \beta^(q^2),..., \beta^(q^(m - 1)) }] of stem:[F_(q^m)] over stem:[F_q] are called normal basis, where stem:[( \beta in F)_(q^m)]_._ stem:[AAa in F_(q^m)], stem:[a] could berepresented as stem:[a = a_0 \beta + a_1 \beta^q + * * * + a_(m - 1) \beta^(q^(m - 1))], where stem:[a_i in F_q]_,_ stem:[i = 0,1,...,m - 1]. For any finite field stem:[F_q] and its extension field stem:[F_(q^m)], such basis always exist.

Unless otherwise specified, all elements in stem:[F_(q^m)] are represented by the polynomial basis.

The field element stem:[a_(m - 1)x^(m - 1) + a_(m - 2)x^(m - 2) + ... + a_1x + a_0] could be represented by the vector stem:[(a_(m - 1),(a_(m - 2), ... ,a_1,a)_0)] in terms of the polynomial basis, so stem:[F_(q^m) = {(a_(m - 1),(a_(m - 2), ... ,a_1,a)_0)|a_i in F_q,i = 0,1, ... ,m - 1 }].

The multiplicative identity is represented by stem:[(0, ... ,0,1)], and the zero element is represented by stem:[(0, ... ,0,0)]. The addition and multiplication of the field elements are defined as follows.

*Addition.* stem:[AA(a_(m - 1),(a_(m - 2), ... ,a_1,a)_0),(b_(m - 1),(b_(m - 2), ... ,b_1,b)_0) in F_(q^m)], then stem:[(a_(m - 1),(a_(m - 2), ... ,a_1,a)_0) + (b_(m - 1),(b_(m - 2), ... ,b_1,b)_0) = (c_(m - 1),(c_(m - 2), ... ,c_1,c)_0)], where stem:[c_i = a_i + b_i], stem:[i = 0,1, ... ,m - 1]. That is, addition is implemented by component-wise addition in stem:[F_q].

*Multiplication.* stem:[AA(a_(m - 1),(a_(m - 2), ... ,a_1,a)_0),(b_(m - 1),(b_(m - 2), ... ,b_1,b)_0) in F_(q^m)], then stem:[(a_(m - 1),(a_(m - 2), ... ,a_1,a)_0) * (b_(m - 1),(b_(m - 2), ... ,b_1,b)_0) = (r_(m - 1),(r_(m - 2), ... ,r_1,r)_0)], where the polynomial stem:[r_(m - 1)x^(m - 1) + r_(m - 2)x^(m - 2) + * * * + r_1x + r_0] is the remainder of stem:[(a_(m - 1)x^(m - 1) + a_(m - 2)x^(m - 2) + * * * + a_1x + a_0) * (b_(m - 1)x^(m - 1) + b_(m - 2)x^(m - 2) + * * * + b_1x + b_0)] modulo stem:[f(x)] in stem:[F_q\[x\]].

stem:[F_(q^m)]
 contains stem:[q^m] elements. Let stem:[F_(q^m)^()] be the multiplicative group composed of all nonzero elements in stem:[F_(q^m)]. Since stem:[F_(q^m)] is a multiplicative group, there exists at least one element stem:[g] in stem:[F_(q^m)] such that any nonzero element of stem:[F_(q^m)] can be represented by the powers of stem:[g]. stem:[g] is called the generator (or primitive element) of stem:[F_(q^m)^()], and stem:[F_(q^m)^() = {g^i|0 <= i <= q^m - 2 }]. Let stem:[a = g^i in F_(q^m)^()], where stem:[0 <= i <= q^m - 2], then the multiplicative inverse of stem:[a] is stem:[a^( - 1) = g^(q^m - 1 - i)].

*Example 2:* the polynomial basis representation of stem:[F_(3^2)].

Let stem:[f(x) = x^2 + 1] be an irreducible polynomial over stem:[F_3], then the elements of stem:[F_(3^2)] are stem:[(0,0)], stem:[(0,1)], stem:[(0,2)], stem:[(1,0)], stem:[(1,1)], stem:[(1,2)], stem:[(2,0)], stem:[(2,1)], stem:[(2,2)].

*Addition*: stem:[(2,1) + (2,0) = (1,1)]

*Multiplication*: stem:[(2,1) * (2,0) = (2,2)]

stem:[(2x + 1) * 2x = 4x^2 + 2x] stem:[x^2 + 2x] stem:[2x + 2( mod f(x))]

That is, stem:[2x + 2] is the reminder of stem:[(2x + 1) * 2x] modulo stem:[f(x)].

The multiplicative identity is stem:[(0,1)], and stem:[\alpha = x + 1] is a generator of stem:[F_(3^2)^()], then the powers of stem:[\alpha] are +
stem:[\alpha^0 = (0,1)], stem:[\alpha^1 = (1,1)], stem:[\alpha^2 = (2,0)], stem:[\alpha^3 = (2,1)], stem:[\alpha^4 = (0,2)], stem:[\alpha^5 = (2,2)], stem:[\alpha^6 = (1,0)], stem:[\alpha^7 = (1,2)], stem:[\alpha^8 = (0,1)].

==== Elliptic curves over finite fields

===== Overview

There are two common representations for the elliptic curves over finite fields: an affine coordinate and a projective coordinate.

===== Affine coordinate

Suppose stem:[p] is a prime greater than 3, the elliptic curve equation over stem:[F_(p^m)] in the affine coordinate system can be simplified as stem:[y^2 = x^3 + ax + b], where stem:[a,b in F_p], satisfying stem:[(4a^3 + 27b^2) mod p != 0]. The set of points on the elliptic curve is denoted by stem:[E(F_(p^m)) = {(x,y)|x,y in F_(p^m), satisfying the equation y^2 = x^3 + ax + b } uu { O }], where stem:[O] in the point at infinity, also called the zero point.

The points on stem:[E(F_(p^m))] form an abelian group according to the following addition operation rules:
. stem:[O + O = O];
. stem:[\[\[\],\[AAP = (x,y) in E(F_(p^m))\]\]], stem:[P + O = O + P = P];
. stem:[\[\[\],\[AAP = (x,y) in E(F_(p^m))\]\]], the inverse element of stem:[P] is stem:[– P = (x, - y),P + ( - P) = O];
. stem:[\[\[\],\[P_1 = (x_1,y_1) in E(F_(p^m))\]\]], stem:[\[\[\],\[P_2 = (x_2,y_2) in E(F_(p^m)) { O } \]\]], and stem:[P_3 = (x_3,y_3) = P_1 + P_2 != O], then
stem:[{\[\[x_3 = \lambda^2 - x_1 - x_2,\],\[y_3 = \lambda (x_1 - x_3) - y_1,\]\]]

where

stem:[\lambda = {\[\[(y_2 - y_1)/(x_2 - x_1), if x_1 != x_2,\],\[(3x_1^2 + a)/(2y_1), if x_1 = x_2, ^^ P_2 != - P_1.\]\]]

*Example 3: an elliptic curve over* stem:[F_(19)]

The equation over stem:[F_(19)]: stem:[y^2 = x^3 + x + 1], where stem:[a = 1], stem:[b = 1]. The points on the curve are:

stem:[(0,1)] , stem:[(0,18)], stem:[(2,7)], stem:[(2,12)], stem:[(5,6)], stem:[(5,13)], stem:[(7,3)], stem:[(7,16)], stem:[(9,6)], stem:[(9,13)], stem:[(10,2)], stem:[(10,17)], stem:[(13,8)], stem:[(13,11)], stem:[(14,2)], stem:[(14,17)], stem:[(15,3)], stem:[(15,16)], stem:[(16,3)], stem:[(16,16)].

There are 21 points (including stem:[O]) on stem:[E(F_(19))].

. Let stem:[P_1 = (10,2)], stem:[P_2 = (9,6)], then compute stem:[P_3 = P_1 + P_2]:

stem:[\lambda = (y_2 - y_1)/(x_2 - x_1) = (6 - 2)/(9 - 10) = (4)/( - 1) = - 4 -= 15( mod 19),] stem:[x_3 = 152 - 10 - 9 = 225 - 10 - 9 = 16 - 10 - 9 = - 3 -= 16( mod 19),] stem:[y_3 = 15 xx (10 – 16) – 2 = 15 xx ( – 6) – 2 -= 3( mod 19),]

thus, stem:[P_3 = (16,3)].


. Let stem:[P_1 = (10,2)], then compute stem:[\[2\]P_1]:

stem:[\lambda = (3x_1^2 + a)/(2y_1) = (3 xx 10^2 + 1)/(2 xx 2) = (3 xx 5 + 1)/(4) = (16)/(4) = 4( mod 19),] stem:[x_3 = 42 - 10 - 10 = - 4 -= 15( mod 19),] stem:[y_3 = 4 xx (10 – 15) – 2 = – 22 -= 16( mod 19),]

thus, stem:[\[2\]P_1 = (15,16)].

===== Projective coordinate

====== Standard projective coordinate system

The elliptic curve equation over stem:[F_(p^m)] in the standard projective coordinate system can be simplified as stem:[y^2z = x^3 + ax z^2 + bz^3], where stem:[a,b in F_(p^m)], satisfying stem:[4a^3 + 27b^2 != 0]. The set of points on the elliptic curve is denoted by stem:[E(F_(p^m)) = {(x,y,z)|x,y,z in F_(p^m), satisfying the equation y^2z = x^3 + ax z^2 + bz^3 }]. For stem:[(x_1,y_1,z_1)] and stem:[(x_2,y_2,z_2)], if there is a stem:[u in F_(p^m)] ( stem:[u != 0]) such that stem:[x_1 = ux_2], stem:[y_1 = uy_2], and stem:[z_1 = uz_2], then these two triples are equivalent, and they represent the same point.

If stem:[z != 0], let stem:[X = x // z], stem:[Y = y // z], then the standard projective coordinates can be converted to the affine coordinates: stem:[Y^2 = X^3 + aX + b].

If stem:[z = 0], then the point stem:[(0,1,0)] corresponds to the point at infinity stem:[O] of the affine coordinate system.

In the standard projective coordinate system, the addition of the points on stem:[E(F_(p^m))] is defined as follows:
. stem:[O + O = O];
. stem:[\[\[\],\[AAP = (x,y,z) in E(F_(p^m))\]\]], stem:[P + O = O + P = P];
. stem:[\[\[\],\[AAP = (x,y,z) in E(F_(p^m))\]\]], the inverse element of stem:[P] is stem:[– P = ( ux , - uy , uz ),u in F_(p^m)(u != 0),and P + ( - P) = O];
. Let stem:[\[\[\],\[P_1 = (x_1,y_1,z_1) in E(F_(p^m))\]\]], stem:[\[\[\],\[P_2 = (x_2,y_2,z_2) in E(F_(p^m))\]\]], and stem:[P_3 = P_1 + P_2 = (x_3,y_3,z_3) != O]. +

If stem:[P_1 != P_2], then +
stem:[\lambda_1 = x_1z_2], stem:[\lambda_2 = x_2z_1], stem:[\lambda_3 = \lambda_1 - \lambda_2], stem:[\lambda_4 = y_1z_2], stem:[\lambda_5 = y_2z_1], stem:[\lambda_6 = \lambda_4 - \lambda_5], stem:[\lambda_7 = \lambda_1 + \lambda_2], stem:[\lambda_8 = z_1z_2], stem:[\lambda_9 = \lambda_3^2], stem:[\lambda_(10) = \lambda_3 \lambda_9], stem:[\lambda_(11) = \lambda_8 \lambda_6^2 - \lambda_7 \lambda_9], stem:[x_3 = \lambda_3 \lambda_(11)], stem:[y_3 = \lambda_6( \lambda_9 \lambda_1 - \lambda_(11)) - \lambda_4 \lambda_(10)], stem:[z_3 = \lambda_(10) \lambda_8]. +

If stem:[P_1 = P_2], then +
stem:[\lambda_1 = 3x_1^2 + az_1^2], stem:[\lambda_2 = 2y_1z_1], stem:[\lambda_3 = y_1^2], stem:[\lambda_4 = \lambda_3x_1z_1], stem:[\lambda_5 = \lambda_2^2], stem:[\lambda_6 = \lambda_1^2 - 8 \lambda_4], stem:[x_3 = \lambda_2 \lambda_6], stem:[y_3 = \lambda_1(4 \lambda_4 - \lambda_6) - 2 \lambda_5 \lambda_3], stem:[z_3 = \lambda_2 \lambda_5].

====== Jacobian projective coordinate system

The elliptic curve equation over stem:[F_(p^m)] in the Jacobian projective coordinate system can be simplified as stem:[y^2 = x^3 + ax z^4 + bz^6], where stem:[a,b in F_(p^m)], satisfying stem:[4a^3 + 27b^2 != 0]. The set of points on the elliptic curve is denoted by stem:[E(F_(p^m)) = {(x,y,z)|x,y,z in F_(p^m), satisfying the equation y^2 = x^3 + ax z^4 + bz^6 }]. For stem:[(x_1,y_1,z_1)] and stem:[(x_2,y_2,z_2)], if there is a stem:[u in F_(p^m)] ( stem:[u != 0]) such that stem:[x_1 = u^2x_2], stem:[y_1 = u^3y_2], and stem:[z_1 = uz_2], then these two triples are equivalent, and they represent the same point.

If stem:[z != 0], let stem:[X = x // z^2], stem:[Y = y // z^3], then the Jacobian projective coordinates can be converted to the affine coordinates: stem:[Y^2 = X^3 + aX + b].

If stem:[z = 0], then the point stem:[(1,1,0)] corresponds to the point at infinity stem:[O] of the affine coordinate system.

In the Jacobian projective coordinate system, the addition of the points on stem:[E(F_(p^m))] is defined as follows: +
. stem:[O + O = O]; +
. stem:[\[\[\],\[AAP = (x,y,z) in E(F_(p^m))\]\]], stem:[P + O = O + P = P]; +
. stem:[\[\[\],\[AAP = (x,y,z) in E(F_(p^m))\]\]], the inverse element of stem:[P] is stem:[– P = (u^2x, - u^3y, uz ),u in F_(p^m)(u != 0),and P + ( - P) = O]; +
. Let stem:[\[\[\],\[P_1 = (x_1,y_1,z_1) in E(F_(p^m))\]\]], stem:[\[\[\],\[P_2 = (x_2,y_2,z_2) in E(F_(p^m))\]\]], and stem:[P_3 = P_1 + P_2 = (x_3,y_3,z_3) != O]. +
If stem:[P_1 != P_2], then +
stem:[\lambda_1 = x_1z_2^2], stem:[\lambda_2 = x_2z_1^2], stem:[\lambda_3 = \lambda_1 - \lambda_2], stem:[\lambda_4 = y_1z_2^3], stem:[\lambda_5 = y_2z_1^3], stem:[\lambda_6 = \lambda_4 - \lambda_5], stem:[\lambda_7 = \lambda_1 + \lambda_2], stem:[\lambda_8 = \lambda_4 + \lambda_5], stem:[\lambda_9 = \lambda_7 \lambda_3^2], stem:[x_3 = \lambda_6^2 - \lambda_9], stem:[\lambda_(10) = \lambda_9^2 - 2x_3], stem:[\[\[\lambda \],\[(10 \lambda_6 - \lambda_8 \lambda_3^3) // 2\],\[y_3 = \]\]], stem:[z_3 = (z_1z_2 \lambda )_3]. +
If stem:[P_1 = P_2], then +
stem:[\lambda_1 = 3x_1^2 + az_1^4], stem:[\lambda_2 = 4x_1y_1^2], stem:[\lambda_3 = 8y_1^4], stem:[x_3 = \lambda_1^2 - 2 \lambda_2], stem:[y_3 = \lambda_1( \lambda_2 - x_3) - \lambda_3], stem:[z_3 = 2y_1z_1].

==== Order of elliptic curves over finite field

The order of an elliptic curve over finite field stem:[F_(q^m)] is the number of elements in the set stem:[E(F_(q^m))], denoted by stem:[E(F_(q^m))]. According to the Hasse theorem, we have stem:[q^m + 1 - 2q^(m // 2) <= E(F_(q^m)) <= q^m + 1 + 2q^(m // 2)], that is to say, stem:[E(F_(q^m)) = q^m + 1 - t], where stem:[t] is called the Frobenius trace, satisfying stem:[t || <= 2q^(m // 2)].

If the Frobenius trace stem:[t] is divisible by the characteristic of stem:[F_(q^m)], this curve is supersingular; otherwise, it is non-supersingular.

Suppose stem:[E(F_(q^m))] is an elliptic curve over stem:[F_(q^m)], the integer stem:[r] and stem:[q^m] are coprime, then the stem:[r]-order twisted subgroup of stem:[E(F_(q^m))] is stem:[E(F_(q^m))\[r\] = {P in E(F_(q^m))|\[r\]P = O }] and any stem:[P in E(F_(q^m))\[r\]] is an stem:[r]-fulcrum.

=== Elliptic curve scalar multiplication

The operation of adding a point along an elliptic curve to itself repeatedly is called the scalar multiplication of the point. Let stem:[u] be a positive integer, stem:[P] be a point on an elliptic curve, then the stem:[u] multiple of the point stem:[P] is denoted as stem:[Q = \[u\]P = underset(uP's)(ubrace (P + P + ... + P))].

Scalar multiplication can be extended to 0-scalar and negative-scalar: stem:[\[0\]P = 0], stem:[\[- u\]P = \[u\]( - P)].

There are many ways to implement elliptic curve scalar multiplication, and the most fundamental three methods are noted here, where stem:[1 <= u < N].

*Algorithm 1: Binary expansion method*

Input:: a point stem:[P], an stem:[l]-bit long integer stem:[u = sum_(j = 0)^(l - 1)u_j2^j], stem:[u_j in { 0,1 }].

Output:: stem:[Q = \[u\]P].

. Set stem:[Q = O];

. For stem:[j = l - 1] to 0:

.. stem:[Q = \[2\]Q];

.. If stem:[u_j = 1], then stem:[Q = Q + P];

. Output stem:[Q].

*Algorithm 2: Addition and subtraction method*

Input:: a point stem:[P], an stem:[l]-bit long integer stem:[u = sum_(j = 0)^(l - 1)u_j2^j], stem:[u_j in { 0,1 }].

Output:: stem:[Q = \[u\]P].


. Suppose the binary representation of stem:[3u] is stem:[h_rh_(r - 1) ... h_1h_0], and the most significant bit stem:[h_r] is 1. Obviously stem:[r = l] or stem:[r = l + 1];

. The binary representation of stem:[u] is stem:[u_ru_(r - 1) ... u_1u_0];

. Set stem:[Q = P];

. For stem:[i = r - 1] to 1:


.. stem:[Q = \[2\]Q] ;
;

.. If stem:[h_i = 1] and stem:[u_i = 0], then stem:[Q = Q + P];

.. If stem:[h_i = 0] and stem:[u_i = 1], then stem:[Q = Q - P];


. Output stem:[Q].

NOTE: Subtracting the point stem:[(x,y)] is equivalent to adding the point stem:[(x, - y)]. There are many different methods to accelerate this operation.

*Algorithm 3:**Sliding window method*

Input:: a point stem:[P], an stem:[l]-bit long integer stem:[u = sum_(j = 0)^(l - 1)u_j2^j], stem:[u_j in { 0,1 }].

Output:: stem:[Q = \[u\]P].

Let the window length stem:[r > 1].

Pre-computation:

. stem:[P_1 = P] , stem:[P_2 = \[2\]P];, stem:[P_2 = \[2\]P];

. For stem:[i = 1] to stem:[2^(r - 1) - 1], compute stem:[P_(2i + 1) = P_(2i - 1) + P_2];

. Set stem:[j = l - 1], stem:[Q = 0].

Main loop:


. When stem:[j >= 0]:

.. if stem:[u_j = 0], then stem:[Q = \[2\]Q], stem:[j = j - 1];

.. Otherwise

... let stem:[t] be the smallest integer satisfying stem:[j - t + 1 <= r] and stem:[u_t = 1];

... stem:[h_j = sum_(i = 0)^(j - t)u_(t + i)2^i] ;

... stem:[Q = \[2^(j - t + 1)\]Q + P_(h_j)] ;

... set stem:[j = t - 1];

. Output stem:[Q].

=== Discrete logarithm problem

==== Methods to solve the field discrete logarithm problem

Let stem:[F_q^()] be the multiplicative group composed of all nonzero elements in the finite field stem:[F_q]. We call stem:[g] the generator of stem:[F_q^()], and stem:[F_q^() = {g_i|0 <= i <= q - 2 }]. The order of stem:[a in F_q] is the smallest positive integer stem:[t] satisfying stem:[a^t = 1]. The order of the multiplicative group stem:[F_q^()] is stem:[q - 1], so stem:[t || q - 1].

Suppose the generator of the multiplicative group stem:[F_q^()] is stem:[g] and stem:[y in F_q^()], the finite field discrete logarithm problem is to determine the integer stem:[x in \[0,q - 2\]] such that stem:[y = g^x mod q].

The existing attacks on the finite field discrete logarithm problem are:


. Pohlig-Hellman method: let stem:[l] be the largest prime divisor of stem:[q - 1], then the time complexity is stem:[O(l^(1 // 2))];

. BSGS method: the time and space complexity are both stem:[( \piq // 2)^(1 // 2)];

. Pollard's method: the time complexity is stem:[( \piq // 2)^(1 // 2)];

. Parallel Pollard's method: let stem:[s] be the number of parallel processors, the time complexity reduces to stem:[( \piq // 2)^(1 // 2) // s];

. Linear sieve method (for the prime fields stem:[F_q]): the time complexity is stem:[exp (1 + o(1)( log q)^(1 // 2)( log log q)^(1 // 2))];

. Gauss integer method (for the prime fields stem:[F_q]): the time complexity is stem:[exp (1 + o(1)( log q)^(1 // 2)( log log q)^(1 // 2))];

. Remainder listing sieve method (for prime fields stem:[F_q]): the time complexity is stem:[exp (1 + o(1)( log q)^(1 // 2)( log log q)^(1 // 2))];

. Number field sieve method (for prime fields stem:[F_q]): the time complexity is stem:[exp (((64 // 9)^(1 // 3) + o(1))( log q( log log q)^2)^(1 // 3))];

. Function field sieve method (for fields of small characteristics): the time complexity is stem:[exp (c( log q( log log q)^2)^(1 // 4 + o(1)))] and quasi-polynomial time.

From the above enumerated methods for the finite field discrete logarithm problems and their time complexity, we know that: for discrete logarithm problems over fields of large characteristics, there are attack methods with sub-exponential complexity; for discrete logarithm problems over fields of small characteristics, there are quasi-polynomial time attack methods.

==== Methods to solve the elliptic curve discrete logarithm problem

For an elliptic curve stem:[E(F_q)], the point stem:[P in E(F_q)] with order stem:[n] and stem:[Q in (: P :)], the elliptic curve discrete logarithm problem is to determine the integer stem:[u in \[0,n - 1\]] such that stem:[Q = \[u\]P].

The existing attacks on ECDLP are:


. Pohlig-Hellman method: let stem:[l] be the largest prime divisor of stem:[n], then the time complexity is stem:[O(l^(1 // 2))];

. BSGS method: the time and space complexity are both stem:[( \pin // 2)^(1 // 2)];

. Pollard's method: the time complexity is stem:[( \pin // 2)^(1 // 2)];

. Parallel Pollard's method: let stem:[r] be the numbers of parallel processors, the time complexity reduces to stem:[( \pin // 2)^(1 // 2) // r];

. MOV method: Reduces the ECDLP over supersingular curves and similar curves to DLP over stem:[F_q]'s small extension fields (This is a method of sub-exponential complexity);

. Anomalous method: efficient attack methods for the anomalous curves (curves of stem:[E(F_q) = q]) (This is a method of polynomial complexity);
. GHS method: use Weil descent technique to solve the ECDLP of curves over binary extension field (the extension degree is a composite number), and convert the ECDLP to hyper-elliptic curve discrete logarithm problem, and there is the algorithm with sub-exponential complexity to this problem.
. DGS-points decomposing method: use to compute the indexes used by elliptic curve discrete logarithm over low-degree extension fields. In some special cases, its complexity is lower than the square-root time method.

From the above description and analysis of ECDLP solutions and their time complexity, we can know that: for the discrete logarithm problem of general curves, the current solutions have exponential complexity, and no efficient attack method with sub-exponential complexity has been found; and for the discrete logarithm problem of some special curves, there are attack algorithms with polynomial complexity or sub-exponential complexity.

=== Compression of points on elliptic curve

==== Overview

For any nonzero point stem:[P = (x_P,y_P)] on stem:[E(F_q)], this point can be represented simply by the stem:[x]-coordinate and a specific bit derived from stem:[y_P]. This is the compression representation of points.

==== Compression and decompression methods for points on elliptic curves over stem:[F_p]

Let stem:[P = (x_P,y_P)] be a point on stem:[E(F_p) : y^2 = x^3 + ax + b], and stem:[overset(tilde)(y)_P] be the rightmost bit of stem:[y_P], then stem:[P] can be represented by stem:[x_P] and the bit stem:[overset(tilde)(y)_P].

The method of recovering stem:[y_P] from stem:[x_P] and stem:[overset(tilde)(y)_P] is as follows:

. Compute the field element stem:[\alpha = x_P^3 + ax_P + b] in stem:[F_p];

. Compute the square root stem:[\beta] of stem:[\alpha] in stem:[F_p] (referring to Annex C.1.4). If no square root exists, then report an error;

. If the rightmost bit of stem:[\beta] is equal to stem:[overset(tilde)(y)_P], then set stem:[y_P = \beta]; otherwise set stem:[y_P = p - \beta].

==== Compression and decompression methods for points on elliptic curve over stem:[F_(q^m)] (where stem:[q] is an odd prime number and stem:[m >= 2] )

Let stem:[P = (x_P,y_P)] be a point on stem:[E(F_(q^m)) : y^2 = x^3 + ax + b], then stem:[y_P] can be represented as stem:[(y_(m - 1),y_(m - 2), ... ,y_1,y_0)]; let stem:[overset(tilde)(y)_P] be the rightmost bit of stem:[y_P], then stem:[P] can be represented by stem:[x_P] and the bit stem:[overset(tilde)(y)_P].

The method of recovering stem:[y_P] from stem:[x_P] and stem:[overset(tilde)(y)_P] is as follows:

. Compute the field element stem:[\alpha = x_P^3 + ax_P + b] in stem:[F_(q^m)] ;

. Compute the square root stem:[\beta] of stem:[\alpha] in stem:[F_(q^m)] (referring to Annex C.1.4). If no square root exists, then report an error;

If in the representation stem:[( \beta_(m - 1), \beta_(m - 2), ... , \beta_1, \beta_0)] of stem:[\beta], the rightmost bit of stem:[\beta_0] is equal to stem:[overset(tilde)(y)_P], then set stem:[y_P = \beta]; otherwise set stem:[y_P = ( \beta_(m - 1)^', \beta_(m - 2)^', ... , \beta_1^', \beta_0^')], where stem:[\beta_i^' = (q - \beta_i) in F_q], stem:[i = 0,1, ... ,m - 1].

== Annex B (informative) Computation of bilinear pairings over elliptic curves

=== Overview

Let an elliptic curve over finite field be stem:[E(F_q)]. If stem:[E(F_q) = cf xx r], stem:[r] is prime, stem:[cf]is the cofactor, then the smallest positive integer stem:[k] satisfying stem:[r || q^k - 1] is known as the elliptic curve's embedding degree relative to stem:[r]. If stem:[G] is an stem:[r] order subgroup of stem:[E(F_q)], the embedding degree of stem:[G] is stem:[k] as well.

Let stem:[overset(´)(F)_q]be an algebraic closure of finite field stem:[F_q], and stem:[E\[r\]] the set of all points of order stem:[r] in _E_( stem:[overset(´)(F)_q]).

=== Miller's algorithm

Let the equation of elliptic curves stem:[E(F_(q^k))] over stem:[F_(q^k)] be stem:[y^2 = x^3 + ax + b], and define the straight line passing through the points stem:[U] and stem:[V] on stem:[E(F_(q^k))] as stem:[g_(U,V) : E(F_(q^k)) -> F_(q^k)]. If the equation of the line passing through the points stem:[U] and stem:[V] is stem:[\lambdax + \deltay + t = 0,] then set function stem:[g_(U,V)(Q) = \lambda x_Q + \delta y_Q + t], where stem:[Q = (x_Q,y_Q)]. When stem:[U = V], stem:[g_(U,V)] is defined as the tangent line passing through the point stem:[U]; if either stem:[U] or stem:[V] is the point at infinity, stem:[g_(U,V)] is a straight line perpendicular to the stem:[x]-axis and passing through the other point. Generally, stem:[g_(U, - U)] is abbreviated as stem:[g_U].

Let stem:[U = (x_U,y_U)], stem:[V = (x_V,y_V)], stem:[Q = (x_Q,y_Q)], stem:[\lambda_1 = (3x_V^2 + a) // (2y_V)], stem:[\lambda_2 = (y_U – y_V) // (x_U – x_V)], then there should have the following properties: +
. stem:[g_(U,V)(O) = g_(U,O)(Q) = g_(O,V)(Q) = 1]; +
. stem:[g_(V,V)(Q) = \lambda_1(x_Q - x_V) - y_Q + y_V,Q != O]; +
. stem:[g_(U,V)(Q) = \lambda_2(x_Q - x_V) - y_Q + y_V,Q != O,U != +- V]; +
. stem:[g_(V, - V)(Q) = x_Q - x_V,Q != O].

Miller's algorithm is an efficient algorithm to compute bilinear pairings.

*Miller's algorithm*

Input:: a curve stem:[E], two points stem:[P] and stem:[Q] on stem:[E], and an integer stem:[c].

Output:: stem:[f_(P,c)(Q)].


. The binary representation of stem:[c] is stem:[c_j ... c_1c_0], and the most significant bit stem:[c_j] is 1;

. Set stem:[f = 1], and stem:[V = P];

. For stem:[i = j - 1] to stem:[0]:

stem:[c] .1) Compute stem:[f = f^2 * g_(V,V)(Q) // g_(2V)(Q)], stem:[V = \[2\]V];

stem:[c] .2) If stem:[c_i = 1], let stem:[f = f * g_(V,P)(Q) // g_(V + P)(Q)], stem:[V = V + P].


. Output stem:[f].

Generally, stem:[f_(P,c)(Q)] is known as the Miller function.

=== Computation of the Weil pairing

Let stem:[E] be an elliptic curve over stem:[F_q], and stem:[r] be a positive integer coprime to stem:[q]. Suppose stem:[\mu_r]is the set of stem:[r]th unit roots, and stem:[k] is the embedding degree relative to stem:[r], that is stem:[r || q^k - 1], then stem:[\mu_r sub F_(q^k)].

Let stem:[G_1 = E\[r\]], stem:[G_2 = E\[r\]], stem:[G_T = \mu_r], then the Weil pairing is a bilinear mapping from stem:[G_1 xx G_2] ==
to stem:[G_T], which is denoted as stem:[e_r].

Let stem:[P in G_1], stem:[Q in G_2], if stem:[P = O] or stem:[Q = O], then stem:[e_r(P,Q) = 1]; if stem:[P != O] and stem:[Q != O], for randomly selected points stem:[T in G_1] and stem:[Q in G_2], which are not the point at infinity, such that neither stem:[P + T] nor stem:[T] equal to stem:[U] or stem:[U + Q], then the Weil pairing is

stem:[e_r(P,Q) = (f_((P + T,r)(Q + U)f_(T,r)(U)f_(U,r)(P + T)f_(Q + U,r)(T)))/(f_((T,r)(Q + U)f_(P + T,r)(U)f_(Q + U,r)(P + T)f_(U,r)(T))) .]

stem:[f_(P + T,r)(Q + U)] , stem:[f_(T,r)(Q + U)], stem:[f_(P + T,r)(U)], stem:[f_(T,r)(U)], stem:[f_(Q + U,r)(P + T)], stem:[f_(Q + U,r)(T)], stem:[f_(U,r)(P + T)], stem:[f_(U,r)(T)] can be computed using the Miller algorithm. If the denominator happens to be 0 during computation, replace the point stem:[T] or stem:[U] and recompute.

=== Computation of the Tate pairing

Let stem:[E] be an elliptic curve over stem:[F_q], stem:[r] be a positive integer coprime to stem:[q], and stem:[k] the embedding degree relative to stem:[r]. Let stem:[Q] be the stem:[r] order on stem:[E(F_(q^k))\[r\]], and stem:[(: Q :)] is the cyclic group generated by stem:[Q]. stem:[(F_(q^k)^())^r] is the set of the stem:[r]th power of each element in stem:[F_(q^k)^()], stem:[(F_(q^k)^())^r] is a subgroup of stem:[F_(q^k)^()], the quotient group of stem:[F_(q^k)^()] about stem:[(F_(q^k)^())^r] is written as stem:[F_(q^k)^() // (F_(q^k)^())^r].

Let stem:[G_1 = E(F_q)\[r\]], stem:[G_2 = (: Q :)], stem:[G_T = F_(q^k)^() // (F_(q^k)^())^r], then the Tate pairing is a bilinear mapping from stem:[G_1 xx G_2] ==
to stem:[G_T], written as stem:[t_r].

Let stem:[P in G_1], stem:[Q in G_2], if stem:[P = O] or stem:[Q = O], then stem:[t_r = 1]; if stem:[P != O] and stem:[Q != O], for randomly selected point stem:[U in E(F_(q^k))] which is not the point at infinity, such that stem:[P != Q], stem:[P != Q + U], stem:[U != - Q], then the Tate pairing is

stem:[t_r(P,Q) = (f_((P,r)(Q + U)))/(f_((P,r)(U))) .]

stem:[f_(P,r)(Q + U)]
 and stem:[f_(P,r)(U)] can be computed using the Miller algorithm. During the computation, if the denominator happens to be 0, replace the point stem:[U] and re-compute.

In practice, the reduced Tate pairings as follows is generally used:

stem:[t_r(P,Q) = {\[\[f_(P,r)(Q)^((q^k - 1)/(r)), ^^ Q != O,\],\[1, ^^ Q = O.\]\]]

The computation amount would be cut in half if the reduced Tate pairings is applied instead of the general Tate pairings. If the embedding degree stem:[k] relative to stem:[r] is an even number, then the computation method of reduced Tate pairings could be further optimized. Algorithm 1 describes the common methods applied to reduce Tate pairings, Algorithm 2, 3 and 4 deal with circumstances when stem:[k = 2d].

*Algorithm 1*

Input:: an integer stem:[r] coprime to stem:[q], stem:[P in E(F_q)\[r\]], stem:[Q in E(F_(q^k))\[r\]].

Output:: stem:[t_r(P,Q)].


. The binary representation of stem:[r] is stem:[r_j ... r_1r_0], and the most significant bit stem:[r_j] is 1;

. Set stem:[f = 1], stem:[V = P];

. For stem:[i = j - 1] to 0:

.. Compute stem:[f = f^2 * g_(V,V)(Q) // g_(2V)(Q)], stem:[V = \[2\]V];

.. If stem:[r_i = 1], let stem:[f = f * g_(V,P)(Q) // g_(V + P)(Q)], stem:[V = V + P].


. Compute stem:[f = f^(q^d - 1)];

. Compute stem:[f = f^((q^d + 1)/r)].

. Output stem:[f].

*Algorithm 2*

Input:: an integer stem:[r] coprime to stem:[q], stem:[P in E(F_q)\[r\]], stem:[Q in E(F_(q^k))\[r\]].

Output:: stem:[t_r(P,Q)].


. The binary representation of stem:[r] is stem:[r_j ... r_1r_0], and the most significant bit stem:[r_j] is 1;

. Set stem:[f = 1], stem:[V = P];

. For stem:[i = j - 1] to 0:

.. Compute stem:[f = f^2 * g_(V,V)(Q) // g_(2V)(Q)], stem:[V = \[2\]V];

.. If stem:[r_i = 1], let stem:[f = f * g_(V,P)(Q) // g_(V + P)(Q)], stem:[V = V + P].


. Compute stem:[f = f^(q^d - 1)];

. Compute stem:[f = f^((q^d + 1)/r)];

. Output stem:[f].

*Algorithm 3*

If stem:[F_(q^k)] ( stem:[k = 2d]) is seen as the quadratic extension of stem:[F_(q^d)], then the elements in stem:[F_(q^k)] can be represented as stem:[w = w_0 + iw_1], where stem:[w_0,w_1 in F_(q^d)], then the conjugate of stem:[w] is stem:[overset(´)(w) = w_0 - iw_1], and in this case, the inverse in algorithm 1 can be replaced with conjugate.

Input:: an integer stem:[r]coprime to stem:[q], stem:[P in E(F_q)\[r\]], stem:[Q in E(F_(q^k))\[r\]].

Output:: stem:[t_r(P,Q)].


. The binary representation of stem:[r] is stem:[r_j ... r_1r_0], and the most significant bit stem:[r_j] is 1;

. Set stem:[f = 1], stem:[V = P];

. For stem:[i = j - 1] to 0:

.. Compute stem:[f = f^2 * g_(V,V)(Q) // g_(2V)(Q)], stem:[V = \[2\]V];

.. If stem:[r_i = 1], let stem:[f = f * g_(V,P)(Q) // overset(´)(g)_(V + P)(Q)], stem:[V = V + P].

. Compute stem:[f = f^(q^d - 1)];

. Compute stem:[f = f^((q^d + 1)/r)];

. Output stem:[f].

*Algorithm 4*

When stem:[q] is a prime greater than 3, then the point stem:[Q in E'], where stem:[E'] is the torsion curve of stem:[E]. In this case, the algorithm could be further optimized.

Input:: stem:[P in E(F_q)\[r\]], stem:[Q in E'(F_(q^d))\[r\]], an integer stem:[r].

Output:: stem:[t_r(P,Q)].

. The binary representation of stem:[r] is stem:[r_j ... r_1r_0], and the most significant bit stem:[r_j] is 1;

. Set stem:[f = 1], stem:[V = P];


. For stem:[i = j - 1] to 0:

.. Compute stem:[f = f^2 * g_(V,V)(Q)], stem:[V = \[2\]V];

.. If stem:[r_i = 1], let stem:[f = f * g_(V,P)(Q)], stem:[V = V + P].

. Compute stem:[f = f^(q^d - 1)];

. Compute stem:[f = f^((q^d + 1)/r)];

. Output stem:[f].

=== Computation of the Ate pairing

Let stem:[\pi_q] be the Frobenius endomorphism, stem:[\pi_q : E -> E,(x,y) |-> (x^q,y^q)]; let stem:[\[q\]] be the mapping: stem:[E -> E,Q |-> \[q\]Q]; stem:[\[1\]] unit map; the dual of stem:[\pi_q] is stem:[\pi_q^'], satisfying stem:[\pi_q * \pi_q^' = \[q\]]; stem:[Ker ()] refers to the kernel of the mapping; let the Frobenius trace of elliptic curve stem:[E(F_q)] be stem:[t], and stem:[T = t - 1].

The computation methods for Ate pairings under various structures are given below.

==== Computation of the Ate pairing over stem:[G_2 xx G_1]

Let stem:[G_1 = E\[r\] nn Ker ( \pi_q - \[1\])], stem:[G_2 = E\[r\] nn Ker ( \pi_q - \[q\])], stem:[P in G_1], stem:[Q in G_2]. Define the Ate pairings over stem:[G_2 xx G_1] as:

stem:[Ate : G_2 xx G_1 -> F_(q^k)^() // (F_(q^k)^())^r] stem:[(Q,P) |-> f_(Q,T)(P)^((q^k - 1) // r) .]

The computation method for Ate pairings on stem:[G_2 xx G_1] is given below.

Input:: stem:[G_1 = E\[r\] nn Ker ( \pi_q - \[1\])], stem:[G_2 = E\[r\] nn Ker ( \pi_q - \[q\])], stem:[P in G_1], stem:[Q in G_2], an integer stem:[T = t - 1].

Output:: stem:[Ate (Q,P)].

. The binary representation of stem:[T] is stem:[t_j ... t_1t_0], and the most significant bit stem:[t_j] is 1;;

. Set stem:[f = 1], stem:[V = Q];

. For stem:[i = j - 1] to 0:

.. Compute stem:[f = f^2 * g_(V,V)(P)], stem:[V = \[2\]V];

.. If stem:[t_i = 1], compute stem:[f = f * g_(V,Q)(Q) // g_(V + Q)(P)], stem:[V = V + Q].

. Compute stem:[f = f^((q^k - 1) // r)];

. Output stem:[f].

==== Computation of the Ate pairing over stem:[G_1 xx G_2]

For supersingular elliptic curves, the definition and technique of Ate pairings mentioned above can be directly applied; whereas for ordinary curves, stem:[G_2] needs to be transformed to torsion curve before Ate pairings could be defined.

===== Ate pairings on supersingular elliptic curves

Let stem:[E] be a supersingular elliptic curve defined over stem:[F_q],

Let stem:[G_1 = E\[r\] nn Ker ( \pi_q^' - \[q\])], stem:[G_2 = E\[r\] nn Ker ( \pi_q^' - \[1\])], stem:[G_T = F_(q^k)^() // (F_(q^k)^())^r], stem:[P in G_1], stem:[Q in G_2]. Define the Ate pairings over stem:[G_1 xx G_2] as:

stem:[Ate : G_1 xx G_2 -> F_(q^k)^() // (F_(q^k)^())^r] stem:[(P,Q) |-> f_(P,T)(Q)^((q^k - 1) // r) .]

The computation method for Ate pairings on stem:[G_1 xx G_2] is given below.

Input:: stem:[G_1 = E\[r\] nn Ker ( \pi_q^' - \[q\])], stem:[G_2 = E\[r\] nn Ker ( \pi_q^' - \[1\])], stem:[P in G_1], stem:[Q in G_2], an integer stem:[T = t - 1].

Output:: stem:[Ate (P,Q)].

. The binary representation of stem:[T] is stem:[t_j ... t_1t_0], and the most significant bit stem:[t_j] is 1;

. Set stem:[f = 1], stem:[V = P];

. For stem:[i = j - 1] to 0:

.. Compute stem:[f = f^2 * g_(V,V)(Q)], stem:[V = \[2\]V];

.. If stem:[t_i = 1], compute stem:[f = f * g_(V,P)(Q) // g_(V + P)(P)], stem:[V = V + P].

. Compute stem:[f = f^((q^k - 1) // r)];

. Output stem:[f].

===== Ate pairings on ordinary curves

For ordinary curves, there exists an integer stem:[e], making stem:[( \pi_q^')^e] the automorphism on stem:[G_1], thus, torsion curve theory could be applied to establish the relationship between stem:[Ate(P,Q)] and stem:[f_(P,T^e)(Q)], where stem:[T = t + 1], and stem:[t] is trace.

Let stem:[E] be an elliptic curve defined over stem:[F_q], stem:[E'] be the stem:[d] == th
 torsion curve of stem:[E], and stem:[k]its embedding degree, stem:[m = gcd (k,d)], stem:[e = k // m], stem:[\zeta square_m] be the stem:[m] == th
 primitive unit root. The value of stem:[d] has three cases when stem:[p >= 5]:

. stem:[d = 6], stem:[\beta = \zeta_m^( - 6)], stem:[E^' : y^2 = x^3 + \betab], stem:[\varphi_6 : E^' -> E : (x,y) |-> ( \beta^( - 1 // 3)x, \beta^( - 1 // 2)y)], stem:[G_1 = E\[r\] nn Ker ( \pi_q - \[1\])], stem:[G_2 = E^'\[r\] nn Ker (\[\beta^( - 1 // 6)\] \pi_q^e - \[1\])].

. stem:[d = 4], stem:[\beta = \zeta_m^( - 4)], stem:[E^' : y^2 = x^3 + \betaax], stem:[\varphi_4 : E^' -> E : (x,y) |-> ( \beta^( - 1 // 2)x, \beta^( - 3 // 4)y)], stem:[G_1 = E\[r\] nn Ker ( \pi_q - \[1\])], stem:[G_2 = E^'\[r\] nn Ker (\[\beta^( - 1 // 4)\] \pi_q^e - \[1\])].

. stem:[d = 2], stem:[\beta = \zeta_m^( - 2)], stem:[E^' : y^2 = x^3 + \beta^2 ax + \beta^3b], stem:[\varphi_2 : E^' -> E : (x,y) |-> ( \beta^( - 1)x, \beta^( - 3 // 2)y)], stem:[G_1 = E\[r\] nn Ker ( \pi_q - \[1\])], stem:[G_2 = E^'\[r\] nn Ker (\[\beta^( - 1 // 2)\] \pi_q^e - \[1\])].

Let stem:[P in G_1], stem:[Q in G_2]. The Ate pairings on stem:[G_1 xx G_2] ==
are defined as:

stem:[Ate : G_1 xx G_2 -> F_(q^k)^() // (F_(q^k)^())^r] stem:[(P,Q) |-> f_(P,T^e)(Q)^((q^k - 1) // r) .]

The computation method is given below.

Input:: stem:[G_1], stem:[G_2], stem:[P in G_1], stem:[Q in G_2], an integer stem:[T = t - 1].

Output:: stem:[Ate (P,Q)].

. Compute stem:[u = T^e];

. The binary representation of stem:[u] is stem:[t_j ... t_1t_0], and the most significant bit stem:[t_j] is 1;

. Set stem:[f = 1], stem:[V = P];

. For stem:[i = j - 1] to 0:

.. Compute stem:[f = f^2 * g_(V,V)(Q)], stem:[V = \[2\]V];

.. If stem:[t_i = 1], compute stem:[f = f * g_(V,P)(Q) // g_(V + P)(Q)], stem:[V = V + P].

. Compute stem:[f = f^((q^k - 1) // r)];

. Output stem:[f].

If the elliptic curve on which the Ate pairings defined on stem:[G_1 xx G_2]
is based is supersingular, then it is easy to see that Ate pairings are more efficient than Tate pairings. However, for ordinary curves, Ate pairings are more computationally efficient than Tate pairings only when stem:[T^e || <= r], therefore, Ate pairings are recommended only when the value of stem:[t] is relatively small.

=== Computation of the R-ate pairing

==== Definition of the R-ate pairing

The "R" in R-ate can be seen as the ratio of two pairings, and it could also be regarded as a certain fixed power of Tate pairings.

Let stem:[A,B,a,b in Z], stem:[A = aB + b]. The Miller function stem:[f_(Q,A)(P)] has the following features:

stem:[f_(Q,A)(P) = f_(Q,aB + b)(P) = f_(Q,aB)(P) * f_(Q,b)(P) * g_(\[aB\]Q,\[b\]Q)(P) // g_(\[A\]Q)(P) = f_(Q,B)^a(P) * f_(\[B\]Q,a)(P) * f_(Q,b)(P) * (g_((\[aB\]Q,\[b\]Q)(P)))/(g_((\[A\]Q)(P)))]

The R-ate pairing is defined as:

stem:[R_(A,B)(Q,P) = (f_(\[B\]Q,a)(P) * f_(Q,b)(P) * (g_((\[aB\]Q,\[b\]Q)(P)))/(g_((\[A\]Q)(P))))^((q^k - 1) // n) = ((f_((Q,A)(P)))/((f_(Q,B)^a(P))))^((q^k - 1) // n) .]

If stem:[f_(Q,A)(P)] and stem:[f_(Q,B)(P)] are non-degenerate Miller functions, then stem:[R_(A,B)(Q,P)] is a non-degenerate pairing.

Let stem:[L_1,L_2,M_1,M_2 in Z], satisfying

stem:[e_n^(L_1)(Q,P) = (f_(Q,A)(P))^(M_1 * (q^k - 1) // n),] stem:[e_n^(L_2)(Q,P) = (f_(Q,B)(P))^(M_2 * (q^k - 1) // n) .]

Let stem:[M = lcm (M_1,M_2)], stem:[m = (M // M_1) * L_1 - a(M // M_2) * L_2].

For the sake of non-degeneracy, stem:[m] is not divisible by stem:[n]. We have:

stem:[e_n^m(Q,P) = e_n^((M)/(M_1)L_1 - a(M)/(M_2)L_2)(Q,P) = ((e_n(Q,P)^(L_1(M)/(M_1))))/((e_n(Q,P)^(aL_2(M)/(M_2)))) = ((f_((Q,A)(P)))/(f_((Q,B)(P))))^(M * (q^k - 1) // n) .]

It is easy to see that stem:[e_n^m(Q,P) = R_(A,B)(Q,P)^M].


Generally, a non-degenerate pairing cannot be provided by any integer pairing stem:[(A,B)], and stem:[(A,B)] has four cases as follows:

1. stem:[(A,B) = (q^i,n)] +
2. stem:[(A,B) = (q,T_1)] +
3. stem:[(A,B) = (T_i,T_j)] +
4. stem:[(A,B) = (n,T_i)].

where stem:[T_i -= q^i( mod n)], stem:[i in Z], and stem:[0 < i < k].

*Case 1:* stem:[(A,B) = (q^i,n)], because stem:[A = aB + b], that is stem:[q^i = an + b], therefore, stem:[b -= q^i( mod n)], and

stem:[((f_((Q,q^i)(P)))/((f_(Q,n)^a(P))))^((q^k - 1) // n) = R_(A,B)(Q,P) = (f_(\[n\]Q,a)(P)f_(Q,b)(P)(g_((\[an \]Q,\[b\]Q)(P)))/(g_((\[q^i\]Q)(P))))^((q^k - 1) // n)]

Because stem:[b -= q^i( mod n)], stem:[g_(\[an \]Q,\[b\]Q)(P) = g_(\[q^i\]Q)(P)]. Furthermore, stem:[f_(\[n\]Q,a)(P) = 1]. Hence

|===
<.^h| <.^h|
stem:[R_(A,B)(Q,P) = f_(Q,q^i)(P)^((q^k - 1) // n) .]

 <.^h| (1)

|===

*Case 2:* stem:[(A,B) = (q,T_1)], that is stem:[q = aT_1 + b]. Then

stem:[((f_((Q,q)(P)))/((f_(Q,T_1)^a(P))))^((q^k - 1) // n) = R_(A,B)(Q,P) = (f_(\[T_1\]Q,a)(P)f_(Q,b)(P)(g_((\[aT_1\]Q,\[b\]Q)(P)))/(g_((\[q\]Q)(P))))^((q^k - 1) // n) .]

Since stem:[f_(\[T_1\]Q,a)(P) = f_(Q,a)^q(P)], therefore

|===
<.^h| <.^h|
stem:[R_(A,B)(Q,P) = (f_(Q,a)^q(P)f_(Q,b)(P)(g_((\[aT_1\]Q,\[b\]Q)(P)))/(g_((\[q\]Q)(P))))^((q^k - 1) // n) .]

 <.^h| (2)

|===

*Case 3:* stem:[(A,B) = (T_i,T_j)], that is stem:[T_i = aT_j + b], then

stem:[((f_((Q,T_i)(P)))/((f_(Q,T_j)^a(P))))^((q^k - 1) // n) = R_(A,B)(Q,P) = (f_(\[T_j\]Q,a)(P)f_(Q,b)(P)(g_((\[aT_j\]Q,\[b\]Q)(P)))/(g_((\[q^i\]Q)(P))))^((q^k - 1) // n) .]

Similarly, since stem:[f_(\[T_j\]Q,a)(P) = f_(Q,a)^(q_j)(P)], therefore

|===
<.^h| <.^h|
stem:[R_(A,B)(Q,P) = (f_(Q,a)^(q_j)(P)f_(Q,b)(P)(g_((\[aT_1\]Q,\[b\]Q)(P)))/(g_((\[q^i\]Q)(P))))^((q^k - 1) // n) .]

 <.^h| (3)

|===

*Case 4:* stem:[(A,B) = (n,T_i)], that is stem:[n = aT_i + b], therefore

stem:[((f_((Q,n)(P)))/((f_(Q,T_i)^a(P))))^((q^k - 1) // n) = R_(A,B)(Q,P) = (f_(\[T_i\]Q,a)(P)f_(Q,b)(P)(g_((\[aT_i\]Q,\[b\]Q)(P)))/(g_((\[n\]Q)(P))))^((q^k - 1) // n) .]

Similarly, from stem:[f_(\[T_i\]Q,a)(P) = f_(Q,a)^(q_i)(P)], we have

|===
<.^h| <.^h|
stem:[R_(A,B)(Q,P) = (f_(Q,a)^(q_i)(P)f_(Q,b)(P)(g_((\[aT_i\]Q,\[b\]Q)(P)))/(g_((\[n\]Q)(P))))^((q^k - 1) // n) .]

 <.^h| (3)

|===

The R-ate pairing of case 1 is also known as stem:[Ate_i] pairing. Pairing computation of cases 2, 3 and 4 require two Miller loops of length stem:[log a] and stem:[log b] respectively. Case 2 and 4 can only alter one parameter stem:[i] to obtain efficient pairings, while case 3 can alter two parameters. Therefore the R-ate pairings of case 3 are usually chosen, then stem:[(A,B) = (T_i,T_j)].

In order to reduce the degree of the Miller loop, various stem:[i] and stem:[j] can be tried to minimize the integers stem:[a] and stem:[b], thus, the degree of the Miller loop could be reduced to stem:[log(r^(1 // \Phi (k)))].

==== Computation of the R-ate pairing on BN curves

Barreto and Naehrig put forward a method to construct ordinary curves over prime field stem:[F_q] suitable for pairings, and curves constructed via this method are called BN curves. The equation of the BN curves is stem:[E : y^2 = x^3 + b], where stem:[b != 0]. The embedding degree stem:[k = 12], the curve order stem:[r] is a prime. The base field feature is stem:[q], the curve order is stem:[r], and the trace stem:[tr] of the Frobenius mapping can be obtained by the parameter stem:[t]:

stem:[q(t) = 36t^4 + 24t^3 + 24t^2 + 6t + 1] stem:[r(t) = 36t^4 + 36t^3 + 18t^2 + 6t + 1] stem:[tr (t) = 6t^2 + 1]

where stem:[t in Z], such that both stem:[q = q(t)] and stem:[r = r(t)] are primes, and in order to achieve a certain security level, stem:[t] must be large enough, which is at least 63 bits long.

There exists 6th order torsion curves for BN curves over stem:[F_(q^2) : E^' : y^2 = x^3 + \beta b], where stem:[\beta in F_(q^2)], which is neither a square root nor cubic root in stem:[F_(q^2)], such that stem:[r || E'(F_(q^2))]. The points in stem:[G_2] can be represented by the points on the torsion curve stem:[E'], stem:[\varphi_6 : E^' -> E : (x,y) |-> ( \beta^( - 1 // 3)x, \beta^( - 1 // 2)y) .] Thus, the computation of pairings is restricted on the point stem:[P] on stem:[E(F_q)] and the point stem:[Q'] on stem:[E'(F_(q^2))].

Frobenius automorphism is stem:[\pi_q], and stem:[\pi_q : E -> E], stem:[\pi_q(x,y) = (x^q,y^q)], stem:[\pi_(q^2) : E -> E], stem:[\pi_(q^2)(x,y) = (x^(q^2),y^(q^2))].

The computation of R-ate pairing is as follows.

Input:: stem:[P in E(F_q)\[r\]], stem:[Q in E'(F_(q^2))\[r\]], stem:[a = 6t + 2].

Output:: stem:[R_a(Q,P)].

. Suppose stem:[a = sum_(j = 0)^(L - 1)a_i2^j], stem:[a_(L - 1) = 1];

. Set stem:[T = Q], stem:[f = 1];

. For stem:[i = L - 2] to 0:

.. Compute stem:[f = f^2 * g_(T,T)(P)], stem:[T = \[2\]T];

.. If stem:[a_i = 1], compute stem:[f = f * g_(T,Q)(P)], stem:[T = T + Q];

. Compute stem:[Q_1 = \pi_q(Q)], stem:[Q_2 = \pi_(q^2)(Q)];

. Compute stem:[f = f * g_(T,Q_1)(P)], stem:[T = T + Q_1];

. Compute stem:[f = f * g_(T, - Q_2)(P)], stem:[T = T - Q_2];

. Compute stem:[f = f^((q^(12) - 1) // r)];

. Output stem:[f].

For more computation methods for Weil pairings, Tate pairings, Ate pairings and R-ate pairings, please refer to (Barreto P, Lynn, Scott M. 2003), (Barreto P, Galbraith S, et al. 2004), (Eisentrager K, Lauter K, Montgomery P. 2003), (Galbraith S, Harrison K, Soldera D. 2002), (Kobayashi T, Aoki K, Imai H. 2006), (Miller V. 2004), (Scott M. 2005), (Scott M. 2006) and (Scott M, Barreto P. 2004).

=== Elliptic curves suitable for pairings

It is relatively easy to construct bilinear pairings for supersingular curves, yet for curves randomly generated, it is difficult to construct computable pairings. Therefore, when considering ordinary curves, ones with a structure suitable for pairings should be selected.

Assume that stem:[E] is an elliptic curve defined over stem:[F_q], if the three conditions listed below are satisfied, then stem:[E] is a curve suitable for pairings:


. stem:[E(F_q)] has a prime factor stem:[r]no less than stem:[sqrt(q)];

. The embedding degree of stem:[E] relative to stem:[r] is less than stem:[log_2(r) // 8];

. The size of the largest prime factor of stem:[r +- 1] equals that of stem:[r].

Below are the steps to construct elliptic curves suitable for pairings:

Step 1: Select stem:[k], compute integer stem:[t], stem:[r] and stem:[q], so that there exists an elliptic curve stem:[E(F_q)] whose trace is stem:[t], and the curve has a subgroup of prime order stem:[r]and its embedding degree is stem:[k].

Step 2: Use complex multiplication method to compute the equation parameter of this curve over stem:[F_q].

For methods to construct elliptic curves suitable for pairings, please refer to (Atkin A, Morain F. 1993), (Barreto P, Lynn B, Scott M. 2002), (Barreto P, Lynn B, Scott M. 2003), (Barreto P, Naehrig M. 2005), (Brezing F, Weng A. 2005), (Duan P, Cui S, Wah Chan C. 2005), (Dupont R, Enge A, Morain F. 2005), (Freeman D. 2006), (Freeman D, Scott M, Tesk E. 2006), (Lay G, Zimmer H. 1994), (Milne J. 2006.), (Miyaji A, Nakabayashi M, Takano S. 2001), (Scott M. 2006) and (Thuen Ø. 2006).

== Annex C (informative) Number-theoretic algorithm

=== Calculation over finite fields

==== Exponentiation operation in finite fields

Let stem:[a] be a positive integer, stem:[g] be an element of field stem:[F_q], then the exponentiation is the process of computing stem:[g^a]. By the binary method described below, exponentiation can be performed efficiently.

Input:: a positive integer stem:[a], a field stem:[F_q] and a field element stem:[g].

Output:: stem:[g^a].


. Set stem:[e = a mod (q - 1)], if stem:[e = 0], then output 1;

. The binary representation of stem:[e] is stem:[e_re_(r - 1) ... e_1e_0], and the most significant bit stem:[e_r] is 1;

. Set stem:[x = g];

. For stem:[i = r - 1] to stem:[0]:

.. Set stem:[x = x^2];

.. If stem:[e_i = 1], set stem:[x = g * x];


. Output stem:[x].

For other accelerated algorithms, please refer to (Brickell et al. 1993), (Knuth 1981).

==== Inverse operation in finite fields

Let stem:[g] be a nonzero element in the field stem:[F_q], then the inverse element stem:[g^( - 1)] is the field element stem:[c] satisfying stem:[g * c = 1]. Since stem:[c = g^(q - 2)], the inverse operation can be implemented using the exponentiation operation. Note that if stem:[q] is prime and stem:[g] is an integer satisfying stem:[1 <= g <= q - 1], then stem:[g^( - 1)] ==
is the integer stem:[c], stem:[1 <= c <= q - 1], and stem:[g * c -= 1( mod q)].

Input:: a field stem:[F_q] and a nonzero field element stem:[g]in stem:[F_q].

Output:: the inverse element stem:[g^( - 1)].


. Compute stem:[c = g^(q - 2)] (see C.1.1);

. Output stem:[c].

A more efficient method is the extended Euclidean algorithm; please refer to (Knuth D. 1981).

==== Generation of Lucas sequences

Let stem:[X] and stem:[Y] be two nonzero integers, then the Lucas sequences stem:[U_k] and stem:[V_k] of stem:[X] and stem:[Y] are defined as follows:

stem:[U_0 = 0] _,_ stem:[U_1 = 1]_,_ if stem:[k >= 2]_,_ stem:[U_k = X * U_(k - 1) – Y * U_(k - 2)];

stem:[V_0 = 2] _,_ stem:[V_1 = X]_,_ if stem:[k >= 2]_,_ stem:[V_k = X * V_(k - 1) – Y * V_(k - 2)].

The recurrences above are suitable for calculating the stem:[U_k] and stem:[V_k] for small stem:[k]'s. For large integers stem:[k], the following algorithm is efficient in the calculation of stem:[U_k mod q] and stem:[V_k mod q].

Input:: an odd prime stem:[p], integers stem:[X] and stem:[Y], a positive integer stem:[k].

Output:: stem:[U_k mod q] and stem:[V_k mod q].


. Set stem:[\Delta = X^2 – 4Y];

. The binary representation of stem:[k] is stem:[k_rk_(r - 1) ... k_1k_0], and the most significant bit stem:[k_r] is 1;

. Set stem:[U = 1]_,_ stem:[V = X];

. For stem:[i = r - 1] to 0:

.. Set stem:[\[\[(U * V) mod p\],\[(U,V) = \]\]]_,_ stem:[(V^2 + \Delta * U^2) // 2 mod p];

.. If stem:[k_i = 1], set stem:[(U,V) = (((U * X + V) // 2) mod p,(X * V + \Delta * U) // 2) mod p];


. Output stem:[U] and stem:[V].

==== Solving square root

===== Solving square root on stem:[F_q]

Let stem:[q] be an odd prime, stem:[g] be an integer satisfying stem:[0 <= g < q], then the square root (mod stem:[q]) of stem:[g] is the integer stem:[y], where stem:[0 <= y < q], such that stem:[y^2 = g( mod q)].

If stem:[g = 0], then there is only one square root, stem:[y = 0]; if stem:[g != 0], then there are zero or two square roots (_mod_ stem:[q]), and if stem:[y] is one root, then the other root is stem:[q - y].

The following algorithm can determine whether the square roots of stem:[g] exist. If it exists, then the algorithm will compute one root.

Input:: an odd prime stem:[q], an integer stem:[g], stem:[0 < g < q].

Output:: if the square roots exist, output a square root mod stem:[q]; otherwise output "no square root".

*Algorithm 1*: For stem:[q = 3( mod 4)], there is a positive integer stem:[u] satisfying stem:[q = 4u + 3].


. Compute stem:[y = g^(u + 1) mod q] (see C.1.1);

. Compute stem:[z = y^2 mod q];

. If stem:[z = g], then output stem:[y]; otherwise output "no square root".

*Algorithm 2:* For stem:[q = 5( mod 8)], there is a positive integer stem:[u] satisfying stem:[q = 8u + 5].


. Compute stem:[z = g^(2u + 1) mod q] (see C.1.1);

. If stem:[z = 1( mod q)], compute stem:[y = g^(u + 1) mod q], output stem:[y] and stop the algorithm;

. If stem:[z = - 1( mod q)], compute stem:[y = (2g * (4g)^u) mod q], output stem:[y] and stop the algorithm;
. d)Output "no square root".

*Algorithm 3*: For stem:[q = 1( mod 8)], there is a positive integer stem:[u] satisfying stem:[q = 8u + 1].


. Set stem:[Y = g];

. Generate the random value stem:[X]_,_ stem:[0 < X < q];

. Compute the Lucas sequences (see B.1.3): stem:[U = U_(4u + 1) mod q]and stem:[V = V_(4u + 1) mod q];

. If stem:[V^2 = 4Y( mod q)], then output stem:[y = (V // 2) mod q] and stop the algorithm;

. If stem:[U mod q != 1] and stem:[U mod q != q - 1], output "no square root"and stop the algorithm;
. f)Go to b).

===== Solving square root on stem:[F_(q^2)]

Let stem:[q] be an odd prime, for a quadratic field extension stem:[F_(q^2)], let the reduced polynomial be stem:[f(x) = x^2 - n,n in F_q], then element stem:[\beta] of stem:[F_(q^2)] can be represented as stem:[a + bx]_,_ stem:[a,b in F_q], then the square root of stem:[\beta] is:

stem:[sqrt( \beta ) = sqrt(a + bx) = +- (sqrt((a + sqrt(a^2 - nb^2))/(2)) + ( xb )/(2sqrt(((a + sqrt(a^2 - nb^2))/(2)))))], or stem:[+- (sqrt((a - sqrt(a^2 - nb^2))/(2)) + ( xb )/(2sqrt(((a - sqrt(a^2 - nb^2))/(2)))))].

The algorithm below can determine if stem:[\beta] has square roots, if yes, calculate one of the roots.

Input:: stem:[\beta = a + bx in F_(q^2)], stem:[\beta != 0], an odd prime number stem:[q].

Output:: if square roots of stem:[\beta]exists, output one square root stem:[z], otherwise output "The square root does not exist".

. Compute stem:[U = a^2 - nb^2];

. Compute the square root of stem:[U mod q] (see C.1.4.1), if the square root of stem:[U mod q] exists, denoted by stem:[w_i], the equality stem:[w_i^2 = U mod q,i = 1,2] holds, go to c); otherwise output "no square root" and stop.

. For stem:[i = 1]to 2:

.. Compute _V=(a+_ stem:[w_i]_)/2_;

.. Compute the square root of stem:[U mod q] (see C.1.4.1). If they exist, choose one square root stem:[y] randomly, then the equality stem:[y^2 = Umodq] holds, go to d); if the square roots of stem:[U mod q] do not exist and stem:[i = 2], output "no square root", then stop.

. Compute stem:[z_1 = b // 2y(modq)], let stem:[z_0 = y];

. Output stem:[z = z_0 + z_1x].

===== Solving square root on stem:[F_(q^m)]

====== Checking square elements on stem:[F_(q^m)]

Let stem:[q] be an odd prime number, stem:[m > 2], stem:[g] a nonzero element on stem:[F_(q^m)], the algorithm below can be used to check if stem:[g] is a square element.

Input:: an element stem:[g] of the field.

Output:: if stem:[g] is a square element then output "square", else output "no square".

. Compute stem:[B = g^((q^m - 1) // 2)] (see C.1.1);

. If stem:[B = 1], output "square";

stem:[c] ) If stem:[B = - 1], output "no square".

====== Solving square root on stem:[F_(q^m)]

Let stem:[q] be an odd prime number, stem:[m >= 2].

Input:: an element stem:[g] of the field.

Output:: if stem:[g] is a square element, output its square root stem:[B]; otherwise, output "no square root"


. Randomly choose a non-square element stem:[Y];

. Compute stem:[q^m - 1 = 2^u xx k], stem:[k] is an odd integer.

. Compute stem:[Y = Y^k].

. Compute stem:[C = g^k].

. Compute stem:[B = g^((k + 1) // 2)].

. If stem:[C^(2^(u - 1)) != 1,] then output "no square root" and stop.

. As long as stem:[C != 1]:

.. Let stem:[I] is the smallest positive integer such that stem:[C^(2^i) = 1];

.. Compute stem:[C = C xx Y^(2^(u - i))];

.. Compute stem:[B = B xx Y^(2^(u - i - 1))];

. Output stem:[B].

=== Probabilistic primality testing

Let stem:[u] be a large positive integer, the following probabilistic algorithm (Miller-Rabin test) can decide whether stem:[u] is a prime or a composite.

Input:: a large odd stem:[u] and a large positive integer stem:[T].

Output:: "probably prime" or "composite".


. Compute stem:[v] and the odd stem:[w] satisfying stem:[u - 1 = 2^v * w];

. For stem:[j = 1] to stem:[T]:

.. Select a random value stem:[a] in the range stem:[\[2,u - 1\]];

.. Set stem:[b = a^wmodu];

.. If stem:[b = 1] or stem:[u - 1], go to b.6);

.. For stem:[i = 1] to stem:[v - 1]:

... Set stem:[b = b^2 mod u];

... If stem:[b = u - 1], go to b.6);

... If stem:[b = 1], output "composite" and stop the algorithm;

... The next stem:[i];

.. Output "composite" and stop the algorithm;

.. The next stem:[j];

. c)Output "probably prime".

If the algorithm outputs "composite", then stem:[u] is a composite. If the algorithm outputs "probably prime", then the probability of a composite stem:[u] is less than stem:[2^( - 2T)]. Thus, by selecting a stem:[T] large enough, then the probability is negligible.

=== Polynomials over finite fields

==== Greatest common divisor

If stem:[f(x) != 0] and stem:[g(x) != 0] are two polynomials whose coefficients are in the field stem:[F_q], there is only one monic polynomial stem:[d(x)] (its coefficients are also in the field stem:[F_q]) with the largest degree, and it divides stem:[f(x)] and stem:[g(x)] simultaneously. The polynomial stem:[d(x)] is called the greatest common divisor of stem:[f(x)] and stem:[g(x)], which is denoted by stem:[gcd(f(x),g(x))]. The following algorithm (the Euclidean algorithm) is used to compute the greatest common divisor of two polynomials.

Input:: a finite field stem:[F_q], and two nonzero polynomials stem:[f(x) != 0] and stem:[g(x) != 0] in stem:[F_q].

Output:: stem:[d(x) = gcd(f(x),g(x))].


. Set stem:[a(x) = f(x)]_,_ stem:[b(x) = g(x)];

. When stem:[b(t) != 0], execute the loop:

.. Set stem:[c(x) = a(x)modb(x)];

.. Set stem:[a(x) = b(x)];

.. Set stem:[b(x) = c(x)];


. Let stem:[\alpha] be the coefficient of the first term in stem:[a(x)] and output stem:[\alpha^( - 1)a(x)].

==== Checking irreducibility of polynomial over stem:[F_q]

Let stem:[f(x)]be the polynomial on stem:[F_q], the following algorithm can be used to check the irreducibility of stem:[f(x)] efficiently.

Input:: the monic polynomial stem:[f(x)] and a prime stem:[q].

Output:: if stem:[f(x)]is irreducible over stem:[F_q], output "yes"; otherwise output "no".


. Set stem:[u(x) = x], stem:[m = deg(f(x))];

. For stem:[i = 1] _to_ stem:[| __m // 2__ |]:

.. Set stem:[u(x) = u(x)^qmodf(x)];

.. Set stem:[d(x) = gcd(f(x),u(x) - x];

.. If stem:[d(x) != 1], output "no" and stop the algorithm;

. c)Output "yes".

=== Elliptic curve algorithms

==== Finding points on elliptic curves

Given an elliptic curve over finite field, the following algorithm can be used to find a point which is not the zero point on the elliptic curve efficiently.

===== Finding points on stem:[E(F_p)] .

Input:: a prime stem:[p], the parameters stem:[a] and stem:[b] of an elliptic curve stem:[E] over stem:[F_p].

Output:: a nonzero point on stem:[E].


. Select a random integer stem:[x], stem:[0 <= x <= p];

. Set stem:[\alpha = (x^3 + ax + b)modp];

. If stem:[\alpha = 0], then output stem:[(x,0)] and stop the algorithm;

. Compute the square root of stem:[\alpha modp] (see C.1.4.1);
. e)If d) outputs "no square root", then go to a);

. Output stem:[(x,y)].

===== Finding points on stem:[E(F_(q^m))(m >= 2)]

Input: finite field stem:[F_(q^m)] ( stem:[q] is an odd prime), the parameters stem:[a] and stem:[b]of an elliptic curve stem:[E] over stem:[F_(q^m)]

Output: a nonzero point on stem:[E].

. Select a random element stem:[x] in stem:[F_(q^m)].

. Compute stem:[\alpha = (x^3 + ax + b)] over stem:[F_(q^m)].

. If stem:[\alpha = 0], then output stem:[(x,0)] and stop the algorithm.

. Compute the square root of stem:[\alpha] over stem:[F_(q^m)], denoted by stem:[y] (see C.1.4.3);
. e)If the output of d) is "no square root", then go to a);

. Output stem:[(x,y)].

==== Finding stem:[l] -order points on elliptic curves

This algorithm can be used to compute the generator of stem:[l]-torsion subgroup of elliptic curves.

Input:: the parameters stem:[a] and stem:[b] of an elliptic curve stem:[E] over stem:[F_q], the order of the curve stem:[E(F_q) = lr], where stem:[l] is a prime number.

Output:: an stem:[l]-order point on stem:[E(F_q)].


. Use the method of C.3.1 to select a point stem:[Q] on the curve randomly.

. Compute stem:[P = \[r\]Q];

. If stem:[P = O] then go to a);

. Output stem:[P].

==== Finding stem:[l] -torsion points on twisted elliptic curves

Let stem:[y^2 = x^3 + ax + b] be the function of the elliptic curve stem:[E] over stem:[F_(q^m)], the order stem:[E(F_(q^m)) = q^m + 1 - t]. Let the equation of its twisted curve stem:[E'] is stem:[y^2 = x^3 + \beta^2 ax + \beta^3b], stem:[\beta] is a non-square element of stem:[F_(q^m)]_,_ stem:[E'(F_(q^m)) = q^m + 1 + t].

Input:: the parameters stem:[a,b, \beta] of the twisted curve stem:[E'(F_(q^m))] of an elliptic curve stem:[E(F_(q^m))], the order stem:[E(F_(q^m)) = n^' = l * r], where stem:[l] is prime.

Output:: an stem:[l]-order point on stem:[E'(F_(q^m))].


. Use the method of C.3.1 to select a point stem:[Q]on stem:[E'(F_(q^m))] randomly.

. Compute stem:[P = \[r\]Q];

. If stem:[P = Q] then go to a); else stem:[P] is an stem:[l]-torsion point.

. Output stem:[P].

[bibliography]
== References

[1] Abdalla M, Lange T, Eds. 2012. Pairing-Based Cryptography - Pairing 2012. Proceedings (2012), vol. 7708 of Lecture Notes in Computer Science, Springer-Verlag

[2] Atkin A, Morain F. 1993. Elliptic Curves and Primality Proving, Mathematics of Computation 61(203): 29-68

[3] Barbulescu R, Gaudry P, Joux A, Thome E. 2014. A Heuristic Quasi-polynomial Algorithm for Discrete Logarithm in Finite Fields of Small Characteristic. In P. Q. Nguyen and E. Oswald, editors, Advances in Cryptology: Proceedings of EUROCRYPT '14, volume 8441 of LNCS, Springer-Verlag, 1-16

[4] Barreto P, Galbraith S, et al. 2004. Efficient Pairing Computation on Supersingular Abelian Varieties. Cryptology ePrint Archive, Report 2004/375

[5] Barreto P, Kim H, Lynn B, et al.2002. Efficient Algorithms for Pairing-based Cryptosystems, Proceedings of CRYPTO 2002, LNCS 2442. Springer-Verlag, 354-369

[6] Barreto P, Lynn B, Scott M. 2002. Constructing Elliptic Curves with Prescribed Embedding Degrees. In: Security in Communication Networks - SCN'2002, LNCS 2576. Springer-Verlag, 263-273

[7] Barreto P, Lynn B, Scott M. 2003. On the Selection of Pairing-friendly Groups. In: Selected Areas in Cryptography - SAC'2003, LNCS 3006. Ottawa, Canada: Springer-Verlag, 17-25

[8] Barreto P, Naehrig M. 2005. Pairing-friendly Elliptic Curves of Prime Order. Cryptology ePrint Archive, Report 2005/133

[9] Boneh D, Franklin M. 2001. Identity Based Encryption from the Weil-pairing, Proceedings of CRYPTO 2001, LNCS 2139. Springer-Verlag, 213-229

[10] Brezing F, Weng A. 2005. Elliptic Curves Sutable for Pairing Based Cryptography, Designs, Codes and Cryptography, 37: 133-141

[11] Brickell E, Gordon D, Mccurley K, et al. 1993. Fast Exponentiation with Precomputation. In: Advances in Cryptology - EUROCRYPT'92, LNCS 658. Berlin: Springer-Verlag, 200-207

[12] Cao Zhenfu, Zhang Fanggou, Eds. 2013. Pairing-Based Cryptography - Pairing 2013. Proceedings (2013), vol. 8365 of Lecture Notes in Computer Science, Springer-Verlag.

[13] Cha J C, Cheon J H. 2002. An Identity-based Signature from Gap Diffie-Hellman Groups, Proceedings of PKC 2002, LNCS 2567. Springer-Verlag, 18-30

[14] Cheng Qi, Wan Daqing and Zhuang Jincheng. 2014. Traps to the BGJT-Algorithm for Discrete Logarithms. ePrint 2014.

[15] Cheon, J. H. 2006. Security Analysis of the Strong Diffie-hellman Problem. In EUROCRYPT (2006), S. Vaudenay, Ed., vol. 4004 of Lecture Notes in Computer Science, Springer-Verlag, 1-11

[16] Duan P, Cui S, Wah Chan C. 2005. Special Polynomial Families for Generating More Suitable Elliptic Curves for Pairing-based Cryptosystems. Cryptology ePrint Archive, Report 2005/342

[17] Dupont R, Enge A, Morain F. 2005. Building Curves with Arbitrary Small MOV Degree over Finite Prime Fields, Journal of Cryptology, 18(2): 79-89

[18] Eisentrager K, Lauter K, Montgomery P. 2003. Fast Elliptic Curve Arithmetic and Improved Weil-pairing Evaluation. In: Topics in Cryptology, CT-RSA03, LNCS 2612. Springer-Verlag, 343-354

[19] Freeman D. 2006. Constructing Pairing-friendly Elliptic Curves with Embedding Degree 10. In: Algorithmic Number Theory Symposium - ANTS-VII, LNCS 4076. Springer-Verlag, 452-465

[20] Freeman D, Scott M, Teske E. 2006. A Taxonomy of Pairing-friendly Elliptic Curves, Cryptology ePrint Archive Report 2006/372

[21] Frey G, Müller M, Rück H. 1999. The Tate-pairing and the Discrete Logarithm Applied to Elliptic Curve Cryptosystems, IEEE Transactions on Information Theory, 45(5): 1717-1719

[22] Galbraith S. 2001. Supersingular Curves in Cryptography, Proceedings of Asiacrypt 2001, LNCS 2248. Springer-Verlag, 495-513

[23] Galbraith S, Harrison K, Soldera D. 2002. Implementing the Tate-pairing, Proceedings of ANTSV, LNCS 2369. Springer-Verlag, 324-337

[24] Galbraith S , Paterson K, Eds. 2008. Pairing-Based Cryptography - Pairing 2008. Proceedings (2008), vol. 5209 of Lecture Notes in Computer Science, Springer-Verlag.

[25] Googlu F, Granger R, McGuire G, and Zumbrael J. 2013. On the Function Field Sieve and the Impact of Higher Splitting Probabilities: Application to discrete logarithms in F21971. Cryptology ePrint Archive, Report 2013/074.

[26] Hess F, Smart N, Vercauteren F. 2006. The Eta-pairing Revisited. Cryptology ePrint Archive, Report 2006/110

[27] IEEE P1363: 2000 Standard for Public Key Cryptography

[28] ISO/IEC 15946-1: 2002 Information Technology—Security Techniques—Cryptographic Techniques Based on Elliptic Curves — Part 1: General

[29] ISO/IEC 15946-2: 2002 Information Technology—Security Techniques—Cryptographic Techniques Based on Elliptic Curves — Part 2: Digital Signatures

[30] ISO/IEC 15946-3: 2002 Information Technology—Security Techniques—Cryptographic Techniques Based on Elliptic Curves — Part 3: Key Establishment

[31] ISO/IEC 15946-4: 2003 Information Technology—Security Techniques—Cryptographic Techniques Based on Elliptic Curves — Part 4: Digital Signatures Giving Message Recovery

[32] ISO/IEC 14888-3: 2004 Information Technology—Security Techniques—Digital Signatures with Appendix  Part 3: Discrete Logarithm Based Mechanisms

[33] ITU-T Recommendation X.680 Information Technology—Abstract Syntax Notation One (ASN.1): Specification of Basic Notation (eqv ISO/IEC 8824-1)

[34] ITU-T Recommendation X.681 Information Technology—Abstract Syntax Notation One (ASN.1): Information Object Specification (eqv ISO/IEC 8824-2)

[35] ITU-T Recommendation X.682 Information Technology—Abstract Syntax Notation One (ASN.1): Constraint Specification (eqv ISO/IEC 8824-3)

[36] ITU-T Recommendation X.683 Information Technology—Abstract Syntax Notation One (ASN.1): Parametrization of ASN.1 Specifications (eqv ISO/IEC 8824-4)

[37] ITU-T Recommendation X.690 Information Technology—ASN.1 Encoding Rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER) (eqv ISO/IEC 8825-1)

[38] ITU-T Recommendation X.691 Information Technology—ASN.1 Encoding Rules: Specification of Packed Encoding Rules (PER) (eqv ISO/IEC 8825-2)

[39] Joux A. 2013. Faster Index Calculus for the Medium Prime Case Application to 1175-bit and 1425-bit Finite Fields. In Advances in Cryptology EUROCRYPT 2013. Springer-Verlag, 177-193

[40] Joux A. 2013. A New Index Calculus Algorithm with Complexity L(1/4 + o(1))in Very Small characteristic. In Selected Areas in Cryptography-SAC 2013, volume 8282 of Lecture Notes in Computer Science, Springer-Verlag, 355-382

[41] Joye M, Miyaji A, Otsuka A, Eds. 2010. Pairing-Based Cryptography - Pairing 2010. Proceedings (2010), vol. 6487 of Lecture Notes in Computer Science, Springer-Verlag.

[42] Knuth D. 1981. The Art of Computer Programming(Vol 2). 2nd ed. Reading(MA): Addison-Wesley

[43] Kobayashi T, Aoki K, Imai H. 2006. Efficient Algorithms for Tate-pairing. IEICE Trans. Fundamentals, E89-A

[44] Koblitz N. 1987. Elliptic Curve Cryptosystems. Mathematics of Computation, 48:203-209

[45] Lauter K, Montgomery P, Naehrig M. 2010. An Analysis of Affine Coordinates for Pairing Computation. Pairing-Based Cryptography - Pairing 2010. Proceedings (2010), vol. 6487 of Lecture Notes in Computer Science, Springer-Verlag.

[46] Lay G, Zimmer H. 1994. Constructing Elliptic Curves with Given Group Order over Large Finite Fields, In: Algorithmic Number Theory Symposium-ANTS-1, LNCS 877. Springer-Verlag, 250-263 Menezes A. 1993. Elliptic Curve Public Key Cryptosystems. Boston: Kluwer Academic Publishers

[47] Lidl R, Niederreiter H. 1983. Finite Fields. Reading(MA): Addison-Wesley Menezes A, Okamoto T, Vanstone S. 1993. Reducing Elliptic Curve Logarithms to Logarithms in a Finite Field. IEEE Transactions on Information Theory, 39: 1639-1646

[48] Miller V. 2004. The Weil-pairing and its Efficient Calculation, Journal of Cryptology, 17:235-261

[49] Milne J. 2006. Complex Multiplication, http://www.jmilne.org/math

[50] Miyaji A, Nakabayashi M, Takano S. 2001. New Explicit Conditions of Elliptic Curve Traces for FR-reduction, IEICE Transactions on Fundamentals, E84-A(5): 1234-1243

[51] Müller V. 1995. Counting the Number of Points on Elliptic Curves over Finite Fields of Characteristic Greater than Three: [Doctorate Dissertation]. Saarlandes: University of Saarlandes

[52] Pollard J. 1978. Monte Carlo Methods for Index Computation mod p. Mathematics of Computation, 32: 918-924

[53] Schoof R. 1985. Elliptic Curves over Finite Fields and the Computation of Square Roots mod p.Mathematics of Computation, 44(170): 483-494

[54] Scott M. 2005. Computing the Tate-pairing. In: CT-RSA, LNCS 3376. Springer-Verlag, 293- 304

[55] Scott M. 2006, Implementing Cryptographic Pairings, ECC 2006

[56] Scott M, Barreto P. 2004. Compressed Pairings. In: Advances in Cryptology Crypto' 2004, LNCS 3152. Springer-Verlag, 140-156

[57] Scott M, Barreto P. 2006. Generating More MNT Elliptic Curves, Designs, Codes and Cryptography, 38: 209-217

[58] Shacham H, Waters B, Eds. 2009. Pairing-Based Cryptography - Pairing 2009. Proceedings (2009), vol. 5671 of Lecture Notes in Computer Science, Springer-Verlag

[59] Silverman J. 1986. The Arithmetic of Elliptic Curves. Berlin: Springer-Verlag, GTM 106

[60] Smart N. 1999. The Discrete Logarithm Problem on Elliptic Curves of Trace One. Journal of Cryptology, 12(3): 193-196

[61] Takagi T, Okamoto T, Okamoto E, and Okamoto T, Eds. 2007. Pairing-Based Cryptography - Pairing 2007. Proceedings (2007), vol. 4575 of Lecture Notes in Computer Science, Springer-Verlag

[62] Thuen Ø. 2006. Constructing Elliptic Curves over Finite Fields Using Complex Multiplication, Master of Science in Physics and Mathematics

[63] ANSI X9.63-2001 Public Key Cryptography for the Financial Services Industry: Key Agreement and Key Transport Using Elliptic Curve Cryptography. American National Standards Institute

[64] ANSI X9.62-1999 Public Key Cryptography for the Financial Services Industry: The Elliptic Curve Digital Signature Algorithm (ECDSA). American National Standards Institute

